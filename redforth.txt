<redforth.img>

// S stack is used for the FORTH value stack
// R stack is used for the FORTH call stack
// I points to the list of command addresses executing

// FORTH words are packed next to each other with no padding
//     in memory, making it easy to iterate the entire list
//     of words. Words start with a header containing the name
//     and the address of the previous word's entry point. The
//     entry point is always directly after the header. Headers
//     are structured as:
//     
//     00 <name> 00 <flags> <address>
//
//     Flag Bits:
//       0: "Immediate" (?)
//       1: Hidden (Not shown in WORDS)

// FORTH programs heavily rely on "special" words that have parenthesis
//     in their names (eg. (lit)). These are unintended to be used directly
//     by the programmer, and often interpret the following information in the
//     call list as data or an address.

// FORTH words always have 'native' entry points with 65EL02
//    machine code. To go to the next word in the program, the
//    NXT instruction jumps the next word's native entry point
//    in the call list pointed to by I. Some words are implemented
//    as precompiled FORTH programs and start with ENT with the
//    address of the first word's entry point. This causes the
//    CPU to push the call list pointer on the call stack, set it
//    to the address after the ENT instruction (which is a list of
//    entry points) and the word called by ENT will then jump to the
//    next entry point in the list following the ENT.
//    
//    Example:
//
//        Raw FORTH:
//            : FOUR
//            2 DUP +
//            ;
//
//        Compiled FORTH:
//        // Header
//        ----: 00
//        _ascii_FOUR:   | "FOUR"
//        ----: 46 4F 55 52 00 00 -- --
//        // Entry point
//        _func_FOUR:
//        // Jump to entry point for '(lit)', execute following words as FORTH program
//        ----: 22 50 05 | ent _func_lit // (lit)
//        // Precompiled FORTH program
//        ----: 02 00    | 0x0002        //     0x0002
//        ----: 49 06    | _func_DUP     // DUP
//        ----: 8F 07    | _func_plus    // +
//        ----: 5C 05    | _func_EXIT    // EXIT
// 

// DO loops are implemented by pushing the maximum value to the R-stack, followed by the
//     difference between the start and the end (eg. 0 - 10, this is intentionally
//     negative). This is done by a (do) or (?do) command, both of which are followed by
//     the call list address to jump if the loop doesn't execute (this is only checked by
//     the (?do) command, even though both have the address). The loop body follows, which
//     may have a (leave) command which follows with the same address as a (?do), and will
//     clean up the loop variables before jumping. The loop is done by a (loop) or (?loop)
//     command which are both followed by the call list address to loop to. (loop) will
//     increment the count variable (the difference) until it overflows, signalling the loop
//     is finished, where it will continue execution after it. If it is still looping, it will
//     jump to the loop address. (+loop) is the same, but pops a value to add to the loop variable
//     instead of incrementing by 1. DO loops are followed by an UNLOOP command, which cleans up
//     the stack if the loop exits normally after the (loop) or (+loop) command.

_start:
0500: 18       | clc         // Clear emulation flag
0501: FB       | xce
0502: C2 30    | rep 0x30
0504: A9 00 03 | lda 0x300   // Set redbus window offset to 0x300
0507: EF 01    | mmu 0x01
0509: EF 02    | mmu 0x02    // Enable redbus
050B: A9 00 04 | lda 0x400   // Set external memory mapped window to 0x400
050E: EF 03    | mmu 0x03
0510: EF 04    | mmu 0x04    // Enable external memory mapped window
0512: A9 00 05 | lda 0x500   // Set Power-On address to 0x500
0515: EF 06    | mmu 0x06
0517: 4C 56 1D | jmp _func_COLD // Cold boot

// Push next operation, return
051A: 00
_ascii_DOCON:  | "DOCON"
051B: 44 4F 43 4F 4E 00 00 00 00
_func_DOCON:
0524: DC       | tix         // Copy call list to X
0525: B5 00    | lda (X+0x00)// Load A with next call address
0527: 48       | pha         // Push call address to value stack
0528: 2B       | rli         // Pop call list from call stack and continue
0529: 02       | nxt

// Push address of next operation, return
052A: 00 
_ascii_DOVAR:  | "DOVAR"
052B: 44 4F 56 41 52 00 00 24 05
_func_DOVAR:
0534: DC       | tix         // Push next address in call list
0535: DA       | phx
0536: 2B       | rli         // Pop call list and continue
0537: 02       | nxt         

// Pop return location and push value
0538: 00
_ascii_DODOES: | "DODOES"
0539: 44 4F 44 4F 45 53 00 00 34 05
0543: 3B       | rlx         // Pop return address, push value
0544: DA       | phx
0545: 02       | nxt

// Push next operation, continue
0546: 00
_ascii_lit:    | "(lit)"
0547: 28 6C 69 74 29 00 00 43 05
_func_lit:
0550: 42       | nxa         // Push next word
0551: 48       | pha         
0552: 02       | nxt         // Jump to next word

// Return
0553: 00
_ascii_EXIT:   | "EXIT"
0554: 45 58 49 54 00 00 50 05
_func_EXIT:
055C: 2B       | rli
055D: 02       | nxt 

// Jump to new call list given by next value
055E: 00
_ascii_branch: | "(branch)"
055F: 28 62 72 61 6E 63 68 29 00 00 5C 05
_func_branch:
056B: 42       | nxa
056C: AA       | tax
056D: 5C       | txi
056E: 02       | nxt

// Pop value, if zero jump to new call list given by next value
056F: 00
_ascii_qbranch:| "(?branch)"
0570: 28 3F 62 72 61 6E 63 68 29 00 00 6B 05 
_func_qbranch:
057D: 68       | pla
057E: 42       | nxa
057F: D0 02    | bne 0x02
0581: AA       | tax
0582: 5C       | txi
0583: 02       | nxt

// Sets up a do loop on the stacks, skips the next word
0584: 00
_ascii_do:     | "(do)"
0585: 28 64 6F 29 00 00 7D 05
_func_do:
058D: 42       | nxa          // Next word into A
058E: A3 02    | lda [S+0x02] // Load A with S[1]
0590: 4B       | rha          // Push A to call stack
0591: 68       | pla          // Pop S[0]
0592: 38       | sec
0593: E3 00    | sbc [S+0x00] // S[0] - S[1]
0595: 4B       | rha          // Push S[0] - S[1] to R
0596: 68       | pla          // Pop S[1]
0597: 02       | nxt

// Same as (do), but will not execute loop if there is no difference to iterate, jumps to address in next word
0598: 00 
_ascii_qdo:    | "(?do)"
0599: 28 3F 64 6F 29 00 00 8D 05
_func_qdo:
05A2: 42       | nxa              // Save break address
05A3: AA       | tax
05A4: A3 02    | lda [S+0x02]     // S[1] -> A
05A6: 4B       | rha              // Push A to R
05A7: 68       | pla              // Pop S[0]
05A8: 38       | sec              // S[0] - S[1]
05A9: E3 00    | sbc [S+0x00]
05AB: F0 03    | beq _br_qdo_zero
05AD: 4B       | rha              // Push S[0] - S[1] to R
05AE: 68       | pla              // Pop S[1]
05AF: 02       | nxt
_br_loop_zero:
05B0: 6B       | rla              // Pop A from R
05B1: 68       | pla              // Pop S[1]
05B2: 5C       | txi              // Jump to break address
05B3: 02       | nxt

// Increments the do loop variable, if not done iterating jumps to address in next word
05B4: 00
_ascii_loop:   | "(loop)"
05B5: 28 6C 6F 6F 70 29 00 00 A2 05
_func_loop:
05BF: 42       | nxa              // Save loop address
05C0: AA       | tax
05C1: A7 00    | lda [R+0x00]     // R[0]++
05C3: 1A       | inc A
05C4: 47 00    | eor [R+0x00]
05C6: 89 00 80 | bit 0x8000       // If not overflow
05C9: D0 01    | bne _br_qloop_nzero
05CB: 5C       | txi              // Jump to loop address
_br_qloop_nzero:
05CC: A7 00    | lda [R+0x00]     // Increment loop counter
05CE: 1A       | inc A
05CF: 87 00    | sta [R+0x00] 
05D1: 02       | nxt

// Same as (loop), but pops a value and adds to the loop counter instead of incrementing by 1
05D2: 00
_ascii_ploop:  | "(+loop)"
05D3: 28 2B 6C 6F 6F 70 29 00 00 BF 05
_func_ploop:
05DE: 42       | nxa          // Save loop address
05DF: AA       | tax
05E0: A3 00    | lda [S+0x00] // Add top of stack to loop counter
05E2: 18       | clc
05E3: 67 00    | adc [R+0x00]
05E4: 47 00    | eor [R+0x00] // If not overflow
05E6: 89 00 80 | bit 0x8000
05E9: D0 01    | bne 0x01     // Jump to loop address
05EB: 5C       | txi
05EC: 18       | clc          // Save sum of top and loop counter to loop counter
05ED: 68       | pla
05EE: 67 00    | adc [R+0x00]
05F1: 87 00    | sta [R+0x00]
05F3: 02       | nxt

// Pop loop variables and exit loop to address in next word
05F4: 00
_ascii_leave:  | "(leave)"
05F5: 28 6C 65 61 76 65 29 00 00 DE 05
0600: 6B       | pla          // Pop twice
0601: 6B       | pla
0602: 42       | nxa          // Next word
0603: A8       | tay
0604: B6 00    | ldx (Y+0x00) // Jump to call list at address of next word
0606: 5C       | txi
0607: 8A       | txa
0608: 02       | nxt          // Continue

// Cleanup loop variables if loop ends
0609: 00 
_ascii_UNLOOP: | "UNLOOP"
060A: 55 4E 4C 4F 4F 50 00 00 00 06
0614: 6B       | pla         // Pop twice and continue
0615: 6B       | pla
0616: 02       | nxt

// Pushes the value of the loop counter
0617: 00
_ascii_I:      | "I"
0618: 49 00 00 14 06 
061D: A7 00    | lda [R+0x00]// A = return location
061F: 18       | clc
0620: 67 02    | adc [R+0x02]// Add 2nd level return location
0622: 48       | pha         // Push value
0623: 02       | nxt

// Pushes the value of the outer loop counter
0624: 00
_ascii_J:      | "J"
0625: 4A 00 00 1D 06 
062A: A7 04    | lda [R+0x04]
062C: 18       | clc
062D: 67 06    | adc [R+0x06]
062F: 48       | pha
0630: 02       | nxt

// Pops a value and does a raw jump to it
0631: 00
_ascii_EXECUTE:| "EXECUTE" 
0632: 45 58 45 43 55 54 45 00 00 2A 06 
063D: FA       | plx
063E: CA       | dex
063F: DA       | phx
0640: 60       | rts


// Duplicates the value on the stack
0641: 00
_ascii_DUP:    | "DUP"
0642: 44 55 50 00 00 3D 06
_func_DUP:
0649: A3 00    | lda [S+0x00]
064B: 48       | pha
064C: 02       | nxt

// Duplicates the value on the stack if its not zero
064D: 00 
_ascii_qDUP:   | "?DUP"
064E: 3F 44 55 50 00 00 49 06
_func_qDUP:
0656: A3 00    | lda [S+0x00]
0658: F0 01    | beq 0x01
065A: 48       | pha
065B: 02       | nxt

// Duplicates the two values on top of the stack
065C: 00
_ascii_2DUP:   | "2DUP"
065D: 32 44 55 50 00 00 56 06
_func_2DUP:
0665: A3 02    | lda [S+0x02]
0667: 48       | pha
0668: A3 02    | lda [S+0x02]
0669: 48       | pha
066A: 02       | nxt

// Pops the stack
066B: 00
_ascii_DROP:   | "DROP"
066C: 44 52 4F 50 00 00 65 06
_func_DROP:
0675: 68       | pla
0676: 02       | nxt

// Pops 2 values from the stack
0677: 00
_ascii_2DROP:
0678: 32 44 52 4F 50 00 00 75 06
0681: 68       | pla
0682: 68       | pla
0683: 02       | nxt

// Swaps the two values on top of the stack
0684: 00
_ascii_SWAP:   | "SWAP"
0685: 53 57 41 50 00 00 81 06 
_func_SWAP:
068D: 68       | pla
068E: FA       | plx
068F: 48       | pha
0690: DA       | phx
0691: 02       | nxt

// Pops a value 'x', reads the value x elements into the stack, and pushes it
0692: 00
_ascii_PICK:   | "PICK
0693: 50 49 43 4B 00 00 8D 06 
069B: 68       | pla         // Pop value, *2, add 2
069C: 18       | clc
069D: 2A       | rol A
069E: 18       | clc 
069F: 69 02 00 | adc 0x0002
06A2: 48       | pha         // Push modified value
06A3: BA       | tsx         // Read value from stack
06A4: 9B       | txy
06A5: B3 00    | lda [Y+[S+0x00]]
06A7: 83 00    | sta [S+0x00]// Overwrite top
06A9: 02       | nxt

// Reads the value below the top of the stack, and pushes it
06AA: 00 
_ascii_OVER:   | "OVER"
06AB: 4F 56 45 52 00 00 9B 06
_func_OVER:
06B3: A3 02    | lda [S+0x02]
06B5: 48       | pha
06B6: 02       | nxt

// Reads the value 3 values deep into the stack, and pushes it
06B7: 00
_ascii_2OVER:  | "2OVER"
06B8: 32 4F 56 45 52 00 00 B3 06
_func_2OVER:
06C1: A3 04    | lda [S+0x04]
06C2: 48       | pha
06C3: 02       | nxt

// Rotates the top 3 values: S[0] -> S[1] S[1] -> S[2] S[2] -> S[0]
06C4: 00
_ascii_ROT:    | "ROT"
06C5: 52 4F 54 00 00 C1 06 
06CD: 68       | pla 
06CE: FA       | plx
06CF: 7A       | ply
06D0: DA       | phx
06D1: 48       | pha
06D2: 5A       | phy
06D3: 02       | nxt

// Swaps two pairs of two values on top of the stack
06D4: 00
_ascii_2SWAP:  | "2SWAP"
06D5: 32 53 57 41 50 00 00 CD 06
06DE: A3 06    | lda [S+0x06]
06E0: AA       | tax
06E1: A3 02    | lda [S+0x02]
06E3: 83 06    | sta [S+0x06]
06E5: 8A       | txa
06E6: 83 02    | sta [S+0x02]
06E8: A3 04    | lda [S+0x04]
06EA: AA       | tax
06EB: A3 00    | lda [S+0x00]
06ED: 83 04    | sta [S+0x04]
06EF: 8A       | txa
06F0: 83 00    | sta [S+0x00]
06F2: 02       | nxt

// Idenditcal to 'ROT', but rotates out of the stack instead
06F3: 00
_ascii_nROT:   | "-ROT"
06F4: 2D 52 4F 54 00 00 DE 06 
_func_nROT:
06FC: 68       | pla
06FD: FA       | plx
06FE: 7A       | ply
06FF: 48       | pha
0700: 5A       | phy
0701: DA       | phx
0702: 02       | nxt

// Removes the value below the top of the stack
0703: 00 
_ascii_NIP:    | "NIP"
0704: 4E 49 50 00 00 FC 06
_func_NIP:
070B: 68       | pla
070C: FA       | plx
070D: 48       | pha
070E: 02       | nxt

// Pops two values, pushes the top value, then pushes the two values back
070F: 00
_ascii_TUCK:   | "TUCK"
0710: 54 55 43 4B 00 00 0B 07
_func_TUCK:
0718: 68       | pla
0719: FA       | plx
071A: 48       | pha
071B: DA       | phx
071C: 48       | pha
071D: 02       | nxt

// Pops a value and pushes it to the R stack
071E: 00
_ascii_gtR:    | ">R"
071F: 3E 52 00 00 18 07
_func_gtR:
0725: 68       | pla
0726: 4B       | rha
0727: 02       | nxt

// Pops the R stack and pushes the value
0728: 00
_ascii_Rgt:    | "R>"
0729: 52 3E 00 00 25 07
_func_Rgt:
072F: 6B       | rla
0730: 48       | pha
0731: 02       | nxt

// Store value at S[1] to address S[0], pop both
0732: 00 
_ascii_exclamation: | "!"
0733: 21 00 00 2F 07
_func_exclamation:
0738: FA       | plx         // Pop X
0739: 68       | pla         // Pop A
073A: 95 00    | sta (X+0x00) // Store A to [X]
073C: 02       | nxt         // PC = [0x1D61] = 0x550, I += 2

// Add value S[1] to value at address S[0], pop both
073D: 00
_ascii_pexclamation: | "+!"
073E: 2B 21 00 00 38 07
0744: FA       | plx
0745: 68       | pla 
0746: 18       | clc
0747: 75 00    | adc (X+0x00)
0749: 95 00    | sta (X+0x00)
074B: 02       | nxt

// Subtract value S[1] to value at address S[0], pop both
074C: 00 
_ascii_nexclamation: | "-!"
074D: 2D 21 00 00 44 07
0753: FA       | plx
0754: 38       | sec
0755: B5 00    | lda (X+0x00)
0757: E3 00    | sbc [S+0x00]
0759: 95 00    | sta (X+0x00)
075B: 68       | pla
075C: 02       | nxt

// Store 8-bit value at S[1] to address S[0], pop both
075D: 00
_ascii_Cexclamation: | "C!"
075E: 43 21 00 00 53 07 
_func_Cexclamation:
0764: FA       | plx
0765: 68       | pla
0766: E2 20    | sep 0x20
0768: 95 00    | sta (X+0x00)
076A: C2 20    | rep 0x20
076C: 02       | nxt 

// Pop variable, then push its value
076D: 00
_ascii_at:     | "@"
076E: 40 00 00 64 07
_func_at:
0773: FA       | plx
0774: B5 00    | lda [X+0x00]
0776: 48       | pha
0777: 02       | nxt

// Pop variable, then push its 8-bit value
0778: 00
_ascii_Cat:    | "C@"
0779: 43 40 00 00 73 07 
_func_Cat:
077F: FA       | plx         // Pop X = A = [0x1D59]
0780: E2 20    | sep 0x20    // Set M flag
0782: B5 00    | lda [X+0x00] // Load A[0] and zero extend
0784: 8F       | zea
0785: C2 20    | rep 0x20    // Clear M flag
0787: 48       | pha         // Push A
0788: 02       | nxt

// Pops a value, then adds it to the value on top of the stack
0789: 00
_ascii_plus:   | "+"
078A: 2B 00 00 7F 07 
_func_plus:
078F: 68       | pla
0790: 18       | clc
0791: 63 00    | adc [S+0x00]
0793: 83 00    | sta [S+0x00]
0795: 02       | nxt

// Subtracts S[0] from S[1], pops both, and pushes the result
0796: 00
_ascii_minus:  | "-"
0797: 2D 00 00 8F 07
_func_minus:
079C: A3 02    | lda [S+0x02]
079E: 38       | sec
079F: E3 00    | sbc [S+0x00]
07A1: 83 02    | sta [S+0x02]
07A3: 68       | pla
07A4: 02       | nxt

// Performs an extended signed multiplication on two values poped from the stack
// The lower bits are pushed first, followed by the upper bits
07A5: 00
_ascii_Mstar:  | "M*"
07A6: 4D 2A 00 00 9C 07
_func_Mstar:
07AC: 68       | pla
07AD: BA       | tsx
07AE: 38       | sec
07AF: 1F 00    | mul (X+0x00)
07B1: FA       | plx
07B2: 48       | pha
07B3: DF       | phd
07B4: 02       | nxt

// Unsigned version of "M*"
07B5: 00
_ascii_UMstar: | "UM*"
07B6: 55 4D 2A 00 00 AC 07
_func_UMstar:
07BD: 68       | pla
07BE: BA       | tsx
07BF: 18       | clc
07C0: 1F 00    | mul (X+0x00)
07C2: FA       | plx
07C3: 48       | pha
07C4: DF       | phd
07C5: 02       | nxt

// Pops two values off the stack, signed multiplies them, then pushes the result
07C6: 00
_ascii_star:   | "*"
07C7: 2A 00 00 BD 07
_func_star:
07CC: 68       | pla
07CD: BA       | tsx
07CE: 38       | sec
07CF: 1F 00    | mul (X+0x00)
07D1: FA       | plx
07D2: 48       | pha
07D3: 02       | nxt

// Unsigned version of "*"
07D4: 00
_ascii_Ustar:  | "U*"
07D5: 55 2A 00 00 CC 07
_func_Ustar:
07DB: 68       | pla
07DC: BA       | tsx
07DD: 18       | clc
07DE: 1F 00    | mul (X+0x00)
07E0: FA       | plx
07E1: 48       | pha
07E2: 02       | nxt

// Signed divides double-word S[1:2] by S[0], pops 3 values, pushes the remainder then pushes the quotient
07E3: 00
_ascii_SMslashREM: | "SM/REM"
07E4: 53 4D 2F 52 45 4D 00 00 DB 07
_func_SMslashREM:
07EE: FA       | plx
07EF: CF       | pld
07F0: 68       | pla
07F1: DA       | phx
07F2: BA       | tsx
07F3: 38       | sec
07F4: 5F 00    | div (X+0x00)
07F6: FA       | plx
07F7: DF       | phd
07F8: 48       | pha
07F9: 02       | nxt


07FA: 00
_ascii_FMslashMOD: | "FM/MOD"
07FB: 46 4D 2F 4D 4F 44 00 00 EE 07
_func_FMslashMOD:
0805: FA       | plx
0806: CF       | pld
0807: 68       | pla
0808: DA       | phx
0809: BA       | tsx
080A: 38       | sec
080B: 5F 00    | div (X+0x00)
080D: FA       | plx
080E: DF       | phd
080F: 48       | pha
0810: AF       | tda
0811: F0 11    | beq 0x11
0813: DA       | phx
0814: 43 00    | eor [S+0x00]
0816: 89 00 80 | bit 0x8000
0818: F0 0A    | beq 0x0A    // Branch ahead 10 if negative
081B: 68       | pla
081C: 18       | clc
081D: 63 02    | adc [S+0x02]
081F: 83 02    | sta [S+0x02]
0821: BA       | tsx
0822: D6 00    | dec (X+0x00)
0824: 02       | nxt
0825: FA       | plx         // Pop X and end
0826: 02       | nxt

0827: 00
_ascii_UMslashMOD: | "UM/MOD"
0828: 55 4D 2F 4D 4F 44 00 00 05 08
_func_UMslashMOD:
0832: FA       | plx
0833: CF       | pld
0834: 68       | pla
0835: DA       | phx
0836: BA       | tsx
0837: 18       | clc
0838: 5F 00    | div (X+0x00)
083A: FA       | plx
083B: DF       | phd
083C: 48       | pha
083D: 02       | nxt

// Multiplies the top value by 2
083E: 00
_ascii_2star:  | "2*"
083F: 32 2A 00 00 32 08
_func_2star:
0845: 68       | pla
0846: 18       | clc
0847: 2A       | rol A
0848: 48       | pha
0849: 02       | nxt

// Divides the top value by 2
084A: 00
_ascii_2slash: | "2/"
084B: 32 2F 00 00 45 08
_func_2slash:
0851: A3 00    | lda [S+0x00]
0853: 2A       | rol A
0854: 68       | pla
0855: 6A       | ror A
0856: 48       | pha
0857: 02       | nxt

// Pops a value, and unsigned right-shifts the new top of the stack by the value
0858: 00
_ascii_Ugtgt:  | "U>>"
0859: 55 3E 3E 00 00 51 08
_func_Ugtgt:
0860: 7A       | ply      // S[0] = Count
0861: 68       | pla      // S[1] = Value
0862: 18       | clc
0863: 6A       | ror A
0864: 88       | dey
0865: D0 FB    | bne 0xFB
0867: 48       | pha
0868: 02       | nxt

// Pops a value, and left shifts the new top of the stack by the value
0869: 00
_ascii_ltlt:   | "<<"
086A: 3C 3C 00 00 60 08
_func_ltlt:
0870: 7A       | ply
0871: 68       | pla
0872: C0 00 00 | cpy 
0875: F0 05    | beq 0x05
0877: 18       | clc
0878: 2A       | rol A
0879: 88       | dey
087A: D0 FB    | bne 0xFB
087C: 48       | pha
087D: 02       | nxt

// Pops two values, pushes the bitwise AND of the values
087E: 00
_ascii_AND:    | "AND"
087F: 41 4E 44 00 00 70 08
_func_AND:
0886: 68       | pla
0887: 23 00    | and [S+0x00]
0889: 83 00    | sta [S+0x00]
088B: 02       | nxt

// Pops two values, pushes the bitwise OR of the values
088C: 00
_ascii_OR:     | "OR"
088D: 4F 52 00 00 86 08
_func_OR:
0893: 68       | pla
0894: 03 00    | ora [S+0x00]
0896: 83 00    | sta [S+0x00]
0898: 02       | nxt

// Pops two values, pushes the bitwise XOR of the values
0899: 00
_ascii_XOR:    | "XOR"
089A: 58 4F 52 00 00 93 08
08A1: 68       | pla
08A2: 43 00    | eor [S+0x00]
08A4: 83 00    | sta [S+0x00]
08A6: 02       | nxt

// Pops a value and pushes the bitwise inverse of the value
08A7: 00
_ascii_INVERT: | "INVERT"
08A8: 49 4E 56 45 52 54 00 00 A1 08
_func_INVERT:
08B2: 68       | pla
08B3: 49 FF FF | xor 0xFFFF
08B6: 48       | pha
08B7: 02       | nxt

// Pops a value and pushes the negated value
08B8: 00
_ascii_NEGATE: | "NEGATE"
08B9: 4E 45 47 41 54 45 00 00 B2 08
_func_NEGATE:
08C3: 68       | pla
08C4: 49 FF FF | xor 0xFFFF
08C7: 1A       | inc A
08C8: 48       | pha
08C9: 02       | nxt

// Increments the value on top of the stack
08CA: 00
_ascii_oneplus: | "1+"
08CB: 31 2B 00 00 C3 08 
_func_oneplus:
08D1: 68       | pla
08D2: 1A       | inc A
08D3: 48       | pha
08D4: 02       | nxt

// Decrements the value on top of the stack
08D5: 00
_ascii_oneminus: | "1-"
08D6: 31 2D 00 00 D1 08
_func_oneminus:
08DC: 68       | pla
08DD: 3A       | dec A
08DE: 48       | pha
08DF: 02       | nxt

// Pushes the value of the stack pointer. This is the value before the push
08E0: 00
_ascii_SPat:   | "SP@"
08E1: 53 50 40 00 00 DC 08
08E8: BA       | tsx
08E9: DA       | phx
08EA: 02       | nxt

// Pops a value and sets the stack pointer to that value
08EB: 00
_ascii_SPexclamation: | "SP!"
08EC: 53 50 21 00 00 E8 08
_func_SPexclamation:
08F3: FA       | plx
08F4: 9A       | txs
08F5: 02       | nxt

// Pushes the value of the R stack pointer
08F6: 00
_ascii_RPat:   | "RP@"
08F7: 52 50 40 00 00 F3 08
08FE: AB       | trx
08FF: DA       | phx
0900: 02       | nxt

// Pops a value and sets the R stack pointer to that value
0901: 00
_ascii_RPexclamation: | "RP!"
0902: 52 50 21 00 00 FE 08
_func_RPexclamation:
0909: FA       | plx
090A: 8B       | txr
090B: 02       | nxt

// Pops a value, if equal to zero pushes 0xFFFF, else pushes 0x0000
090C: 00
_ascii_zeroeq: | "0="
090D: 30 3D 00 00 09 09
_func_zeroeq:
0913: 68       | pla
0914: F0 04    | beq 0x04
0916: F4 00 00 | pea 0x0000
0919: 02       | nxt
091A: F4 FF FF | pea 0xFFFF
091D: 02       | nxt

// Pops a value, if not equal to zero pushes 0xFFFF, else pushes 0x0000
091E: 00
_ascii_zeroltgt: | "0<>"
091F: 30 3C 3E 00 00 13 09
_func_zeroltgt:
0926: 68       | pla
0927: F0 04    | beq 0x04
0929: F4 FF FF | pea 0xFFFF
092C: 02       | nxt
092D: 48       | pha
092E: 02       | nxt

// Pops a value, if less than zero pushes 0xFFFF, else pushes 0x0000
092F: 00
_ascii_zerolt: | "0<"
0930: 30 3C 00 00 26 09
_func_zerolt:
0936: 68       | pla
0937: 30 04    | bmi 0x04
0939: F4 00 00 | pea 0x0000
093C: 02       | nxt
093D: F4 FF FF | pea 0xFFFF
0940: 02       | nxt

// Pops two values, pushes 0x0000 if equal, else pushes 0xFFFF
0941: 00
_ascii_ltgt:   | "<>"
0942: 3C 3E 00 00 36 09
_func_ltgt:
0948: 68       | pla
0949: C3 00    | cmp [S+0x00]
094B: F0 05    | beq 0x05
094D: 68       | pla
094E: F4 FF FF | pea 0xFFFF
0951: 02       | nxt
0952: 68       | pla
0953: F4 00 00 | pea 0x0000
0956: 02       | nxt

// Pops two values, pushes 0xFFFF if the top is greater, else pushes 0x0000
0957: 00
_ascii_lt:     | "<"
09F8: 3C 00 00 48 09
_func_lt:
095D: 68       | pla
095E: C3 00    | cmp [S+0x00]
0960: 30 07    | bmi 0x07
0962: F0 05    | beq 0x05
0964: 68       | pla
0965: F4 FF FF | pea 0xFFFF
0968: 02       | nxt
0969: 68       | pla
096A: F4 00 00 | pea 0x0000
096D: 02       | nxt

// Pops two values, pushes 0xFFFF if the top is less, else pushes 0x0000
096E: 00
_ascii_gt:     | ">"
096F: 3E 00 00 5D 09
_func_gt:
0974: 68       | pla
0975: C3 00    | cmp [S+0x00]
0977: 30 05    | bmi 0x05
0979: 68       | pla
097A: F4 00 00 | pea 0x0000
097D: 02       | nxt
097E: 68       | pla
097F: F4 FF FF | pea 0xFFFF
0982: 02       | nxt

// Unsigned version of "<"
0983: 00
_ascii_Ult:    | "U<"
0984: 55 3C 00 00 74 09
098A: 68       | pla
098B: C3 00    | cmp [S+0x00]
098D: 90 07    | bcc 0x07
098F: F0 05    | beq 0x05
0991: 68       | pla
0992: F4 FF FF | pea 0xFFFF
0995: 02       | nxt
0996: 68       | pla
0997: F4 00 00 | pea 0xFFFF
099A: 02       | nxt

// Unsigned version of ">"
099B: 00
_ascii_Ugt:    | "U>"
099C: 55 3E 00 00 8A 09
_func_Ugt:
09A2: 68       | pla
09A3: C3 00    | cmp [S+0x00]
09A5: 90 05    | bcc 0x05
09A7: 68       | pla
09A8: F4 00 00 | pea 0x0000
09AB: 02       | nxt
09AC: 68       | pla
09AD: F4 FF FF | pea 0xFFFF
09B0: 02       | nxt

// Pops two values, pushes 0xFFFF if the top is greater or equal, else pushes 0x0000
09B1: 00
_ascii_ltequals: | "<="
09B2: 3C 3D 00 00 A2 09
_func_ltequals:
09B8: 68       | pla
09B9: C3 00    | cmp [S+0x00]
09BB: 30 05    | bmi 0x05
09BD: 68       | pla
09BE: F4 FF FF | pea 0xFFFF
09C1: 02       | nxt
09C2: 68       | pla
09C3: F4 00 00 | pea 0x0000
09C6: 02       | nxt

// Pops two values, pushes 0xFFFF if the top is less or equal, else pushes 0x0000
09C7: 00
_ascii_gtequals: | ">="
09C8: 3E 3D 00 00 B8 09
_func_gtequals:
09CE: 68       | pla
09CF: C3 00    | cmp [S+0x0]
09D1: 30 07    | bmi 0x07
09D3: F0 05    | beq 0x05
09D5: 68       | pla
09D6: F4 00 00 | pea 0x0000
09D9: 02       | nxt
09DA: 68       | pla
09DB: F4 FF FF | pea 0xFFFF
09DE: 02       | nxt

// Pops two values, pushes 0xFFFF if equal, else pushes 0x0000
09DF: 00
_ascii_equals: | "="
09E0: 3D 00 00 CE 09
_func_equals:
09E5: 68       | pla
09E6: C3 00    | cmp [S+0x00]
09E8: F0 05    | beq 0x05
09EA: 68       | pla
09EB: F4 00 00 | pea 0x0000
09EE: 02       | nxt
09EF: 68       | pla
09F0: F4 FF FF | pea 0xFFFF
09F3: 02       | nxt

// Pushes the size of a numeric 'cell' (always 2 for the 65EL02)
09F4: 00
_ascii_CELL:   | "CELL"
09F5: 43 45 4C 4C 00 00 E5 09
09FD: F4 02 00 | pea 0x0002
0A00: 02       | nxt

// Pops a value and pushes the size of that number of cells (2*N for the 65EL02)
0A01: 00
_ascii_CELLS:  | "CELLS"
0A02: 43 45 4C 4C 53 00 00 FD 09
0A0B: 68       | pla
0A0C: 18       | clc
0A0D: 2A       | rol A
0A0E: 48       | pha
0A0F: 02       | nxt

// Pops two values, pushes the maximum value
0A10: 00
_ascii_MAX:    | "MAX"
0A11: 4D 41 58 00 00 0B 0A
0A18: 68       | pla
0A19: C3 00    | cmp [S+0x00]
0A1B: 30 02    | bmi 0x02
0A1D: 83 00    | sta [S+0x00]
0A1F: 02       | nxt

// Pops two values, pushes the minimum value
0A20: 00
_ascii_MIN:    | "MIN"
0A21: 4D 49 4E 00 00 18 0A
_func_MIN:
0A28: 68       | pla
0A29: C3 00    | cmp [S+0x00]
0A2B: 10 02    | bpl 0x02
0A2D: 83 00    | sta [S+0x00]
0A2F: 02       | nxt

// Copies memory S[2] to S[2]+S[0] to S[1] to S[1]+S[0], pops all 3 values
0A30: 00
_ascii_MOVE:   | "MOVE"
0A31: 4D 4F 56 45 00 00 28 0A
_func_MOVE:
0A39: 0B       | rhi
0A3A: 68       | pla
0A3B: 7A       | ply
0A3C: FA       | plx
0A3D: 5C       | txi
0A3E: BB       | tyx
0A3F: A8       | tay
0A40: F0 0B    | beq 0x0B
0A42: E2 20    | sep 0x20
0A44: 42       | nxa
0A45: 95 00    | sta (X+0x00)
0A47: E8       | inx
0A48: 88       | dey
0A49: D0 F9    | bne 0xF9
0A4B: C2 20    | rep 0x20
0A4D: 2B       | rli
0A4E: 02       | nxt

// Fills memory at S[2] to S[2]+S[1] with S[0], pops all 3 values
0A4F: 00
_ascii_FILL:   | "FILL"
0A50: 46 49 4C 4C 00 00 39 0A
_func_FILL:
0A58: 68       | pla         // S[0] -> A : Store value
0A59: 7A       | ply         // S[1] -> Y : Store count
0A5A: FA       | plx         // S[2] -> X : Store address
0A5B: C0 00 00 | cpy 0x0000  // Y == 0 ?
0A5E: F0 0A    | beq 0x0A    // RETURN
0A60: E2 20    | sep 0x20
0A62: 95 00    | sta (X+0x00)// A -> C[X]
0A64: E8       | inx         // X++
0A65: 88       | dey         // Y--
0A66: D0 FA    | bne 0xFA
0A6D: C2 20    | rep 0x20
0A6F: 02       | nxt

// Performs a C-style memcmp as memcmp(S[2], S[1], S[0]), pops 3 values and pushes the result
0A6B: 00
_ascii_MEMCMP: | "MEMCMP"
0A6C: 4D 45 4D 43 4D 50 00 00 58 0A
_func_MEMCMP:
0A76: 0B       | rhi
0A77: 68       | pla
0A78: 7A       | ply
0A79: FA       | plx
0A7A: 5C       | txi
0A7B: BB       | tyx
0A7C: A8       | tay
0A7D: F0 0D    | beq _br_MEMCMP_equal
0A7F: E2 20    | sep 0x20
_br_MEMCMP_loop:
0A81: 42       | nxa
0A82: D5 00    | cmp [X+0x00]
0A84: D0 0B    | bne 0x0B
0A86: E8       | inx
0A87: 88       | dey
0A88: D0 F7    | bne _br_MEMCMP_loop
0A8A: C2 20    | rep 0x20
_br_MEMCMP_equal:
0A8C: 2B       | rli
0A8D: F4 00 00 | pea 0x0000
0A90: 02       | nxt
0A91: C2 20    | rep 0x20
0A93: 2B       | rli
0A94: 30 04    | bmi _br_MEMCMP_less
_br_MEMCMP_greater:
0A96: F4 01 00 | pea 0x0001
0A99: 02       | nxt
_br_MEMCMP_less:
0A9A: F4 FF FF | pea 0xFFFF
0A9D: 02       | nxt

// Pops a string address, pushes the length of the string
0A9E: 00
_ascii_STRLEN: | "STRLEN"
0A9F: 53 54 52 4C 45 4E 00 00 76 0A
_func_STRLEN:
0AA9: A3 00    | lda [S+0x00]
0AAB: AA       | tax
0AAC: A9 00 00 | lda 0x0000
0AAF: E2 20    | sep 0x20
0AB1: D5 00    | cmp (X+0x00)
0AB3: F0 03    | beq 0x03
0AB5: E8       | inx
0AB6: 80 F9    | bra 0xF9
0AB8: C2 20    | rep 0x20
0ABA: 8A       | txa
0ABB: 38       | sec
0ABC: E3 00    | sbc [S+0x00]
0ABE: 83 00    | sta [S+0x00]
0AC0: 02       | nxt

// Same as 'STRLEN', but iterates in reverse to find a NUL
0AC1: 00
_ascii_RSTRLEN: | "RSTRLEN"
0AC2: 52 53 54 52 4C 45 4E 00 00 A9 0A
_func_RSTRLEN:
0ACD: A3 00    | lda [S+0x00]
0ACF: AA       | tax
0AD0: A9 00 00 | lda 0x0000
0AD3: E2 20    | sep 0x20
0AD5: D5 00    | cmp (X+0x00)
0AD7: F0 03    | beq 0x03
0AD9: CA       | dex
0ADA: 80 F9    | bra 0xF9
0ADC: C2 20    | rep 0x20
0ADE: 68       | pla
0ADF: DA       | phx
0AE0: 38       | sec
0AE1: E3 00    | sbc [S+0x00]
0AE3: 83 00    | sta [S+0x00]
0AE5: 02       | nxt

// Pushes a "true" value
0AE6: 00
_ascii_TRUE:   | "TRUE"
0AE7: 54 52 55 45 00 00 CD 0A
_func_TRUE:
0AEF: 22 24 05 | ent _func_DOCON
0AF2: FF FF

// Pushes a "false" value
0AF4: 00
_ascii_FALSE:  | "FALSE"
0AF5: 46 41 4C 53 45 00 00 EF 0A
_func_FALSE:
0AFE: 22 24 05 | ent _func_DOCON
0B01: 00 00

// Pushes 0x0040
0B03: 00
_ascii_SCRATCH: | "SCRATCH"
0B04: 53 43 52 41 54 43 48 00 00 FE 0A
_func_SCRATCH:
0B0F: 22 24 05 | ent _func_DOCON
0B12: 40 00

// Pushes 0x0080
0B14: 00
_ascii_TIB:    | "TIB"
0B15: 54 49 42 00 00 0F 0B
0B1C: 22 24 05 | ent _func_DOCON
0B1F: 80 00

// Pushes the address of the radix variable, used for string-integer conversion
0B21: 00
_ascii_RADIX:  | "RADIX"
0B22: 52 41 44 49 58 00 00 1C 0B
_func_RADIX:
0B2B: 22 34 05 | ent _func_DOVAR
0B2E: 0A 00

// Pushes a space character
0B30: 00
_ascii_BL:     | "BL"
0B31: 42 4C 00 00 2B 0B
_func_BL:
0B37: 22 24 05 | ent _func_DOCON
0B3A: 20 00

// Pops an unsigned number and pushes the address of the number as a string
0B3C: 00
_ascii_UITOA:  | "UITOA"
0B3D: 55 49 54 4F 41 00 00 37 0B
_func_UITOA:
0B46: 22 0F 0B | ent _func_SCRATCH  // SCRATCH    // s x0040
0B49: 50 05    | (lit)              // (lit)
0B4B: 14 00    | 0x0014             //     0x0014 // s x0040 x0014
0B4D: 8F 07    | _func_plus         // +          // s x0054
0B4F: 50 05    | (lit)              // (lit)
0B51: 00 00    | 0x0000             //     0x0000 // s x0054 x0000
0B53: B3 06    | _func_OVER         // OVER       // s x0054 x0000 x0054
0B55: 64 07    | _func_Cexclamation // C!         // s x0054
0B57: DC 08    | _func_oneminus     // 1-         // s x0053
0B59: 8D 06    | _func_SWAP         // SWAP       // x0053 s
0B5B: 50 05    | _func_lit          // (lit)      // x0053 s x0000
0B5D: 00 00    | 0x0000             //     0x0000
0B5F: 2B 0B    | _func_RADIX        // RADIX      // x0053 s x0000 RADIX
0B61: 73 07    | _func_at           // @          // x0053 s x0000 [RADIX]
0B63: 32 08    | _func_UMslashMOD   // UM/MOD     
0B65: FC 06    | _func_nROT         // -ROT
0B67: 50 05    | _func_lit          // (lit)
0B69: 30 00    | 0x0030             //     0x0030
0B6B: 8F 07    | _func_plus         // +
0B6D: 49 06    | _func_DUP          // DUP
0B6F: 50 05    | _func_lit          // (lit)
0B71: 39 00    | 0x0039             //     0x0039
0B73: 74 09    | _func_gt           // >
0B75: 7D 05    | _func_qbranch      // (?branch)
0B77: 7F 0B    | 0x0B7F             //     0x0B7F
0B79: 50 05    | _func_lit          // (lit)
0B7B: 07 00    | 0x0007             //     0x0007
0B7D: 8F 07    | _func_plus         // +
0B7F: B3 06    | _func_OVER         // OVER
0B81: 64 07    | _func_Cexclamation // C!
0B83: B3 06    | _func_OVER         // OVER
0B85: 13 09    | _func_zeroeq       // 0=
0B87: 7D 05    | _func_qbranch      // (?branch)
0B89: 57 0B    | 0x0B57             //     0x0B57
0B8B: 0B 07    | _func_NIP          // NIP
0B8D: 5C 05    | _func_EXIT         // EXIT

0B8F: 00
_ascii_WORD:   | "WORD"
0B90: 57 4F 52 44 00 00 46 0B
0B98: 22 49 06 | ent _func_DUP      // DUP
0B9B: 7F 07    | _func_Cat          // C@         // Test if character is whitespace
0B9D: 49 06    | _func_DUP          // DUP
0B9F: 50 05    | _func_lit          // (lit)
0BA1: 20 00    | 0x0020             //     ' '
0BA3: E5 09    | _func_equals       // =
0BA5: B3 06    | _func_OVER         // OVER
0BA7: 50 05    | _func_lit          // (lit)
0BA9: 09 00    | 0x0009             //     '\t'
0BAB: E5 09    | _func_equals       // =
0BAD: 93 08    | _func_OR           // OR
0BAF: B3 06    | _func_OVER         // OVER
0BB1: 50 05    | _func_lit          //(lit)
0BB3: 0A 00    | 0x000A             //    '\n'
0BB5: E5 09    | _func_equals       // =
0BB7: 93 08    | _func_OR           // OR
0BB9: B3 06    | _func_OVER         // OVER
0BBB: 50 05    | _func_lit          // (lit)
0BBD: 0D 00    | 0x000D             //     '\r'
0BBF: E5 09    | _func_equals       // =
0BC1: 93 08    | _func_OR           // OR
0BC3: 0B 07    | _func_NIP          // NIP
0BC5: 7D 05    | _func_qbranch      // (?branch)  // If not, goto 0x0BCF
0BC7: CF 0B    | 0x0BCF             //     0x0BCF
0BC9: D1 08    | _func_oneplus      // 1+         // Next character
0BCB: 6B 05    | _func_branch       // (branch)
0BCD: 99 0B    | 0x0B99             //     0x0B99 // Loop

0BCF: 49 06    | _func_DUP          // DUP        // If NUL, exit
0BD1: 7F 07    | _func_Cat          // C@
0BD3: 13 09    | _func_zeroeq       // 0=
0BD5: 7D 05    | _func_qbranch      // (?branch)
0BD7: DD 0B    | 0x0BDD             //     0x0BDD
0BD9: 49 06    | _func_DUP          // DUP
0BDB: 5C 05    | _func_EXIT         // EXIT

0BDD: 49 06    | _func_DUP          // DUP
0BDF: 49 06    | _func_DUP          // DUP
0BE1: 7F 07    | _func_Cat          // C@
0BE3: 49 06    | _func_DUP          // DUP
0BE5: 50 05    | _func_lit          // (lit)
0BE7: 20 00    | 0x0020             //     ' '
0BE9: 48 09    | _func_ltgt         // <>
0BEB: B3 06    | _func_OVER         // OVER
0BED: 26 09    | _func_zeroltgt     // 0<>
0BEF: 86 08    | _func_AND          // AND
0BF1: B3 06    | _func_OVER         // OVER
0BF3: 50 05    | _func_lit          // (lit)
0BF5: 09 00    | 0x0009             //     '\t'
0BF7: 48 09    | _func_ltgt         // <>
0BF9: 86 08    | _func_AND          // AND
0BFB: B3 06    | _func_OVER         // OVER
0BFD: 50 05    | _func_lit          // (lit)
0BFF: 0A 00    | 0x000A             //     '\n'
0C01: 48 09    | _func_ltgt         // <>
0C03: 86 08    | _func_AND          // AND
0C05: B3 06    | _func_OVER         // OVER
0C07: 50 05    | _func_lit          // (lit)
0C09: 0D 00    | 0x000D             //     '\r'
0C0B: 48 09    | _func_ltgt         // <>
0C0D: 86 08    | _func_AND          // AND
0C0F: 0B 07    | _func_NIP          // NIP
0C11: 7D 05    | _func_qbranch      // (?branch)
0C13: 1B 0C    | 0x0C1B             //     0x0C1B
0C15: D1 08    | _func_oneplus      // 1+
0C17: 6B 05    | _func_branch       // (branch)
0C19: DF 0B    | 0x0BDF             //     0x0BDF
0C1B: 49 06    | _func_DUP          // DUP
0C1D: 7F 07    | _func_Cat          // C@
0C1F: 7D 05    | _func_qbranch      // (?branch)
0C21: 2D 0C    | 0x0C2D             //     0x0C2D
0C13: 50 05    | _func_lit          // (lit)
0C15: 00 00    | 0x0000             //     0x0000
0C17: B3 06    | _func_OVER         // OVER
0C19: 64 07    | _func_Cexclamation // C!
0C1B: D1 08    | _func_oneplus      // 1+
0C1D: 8D 06    | _func_SWAP         // SWAP
0C1F: 5C 05    | _func_EXIT  // EXIT

// Performs a string split operation:
// Pops a character codepoint, followed by a string address
// The string is iterated until the first occurence of a different character is found, this address is saved
// The string is then iterated until the first occurrence of the character or the string ends
// If the string end was not reached, the character at this location is set to NUL and the address incremented
// This new address is pushed first, and the first occurence address is pushed next
0C31: 00
_ascii_SPLIT:  | "SPLIT"
0C32: 53 50 4C 49 54 00 00 98 0B
_func_SPLIT:                                       // a b
0C3B: 22 8D 06 | ent _func_SWAP     // SWAP        // b a       // First occurence of B is found
0C3E: B3 06    | _func_OVER         // OVER        // b a b
0C40: B3 06    | _func_OVER         // OVER        // b a b a
0C42: 7F 07    | _func_Cat          // C@          // b a b [a]
0C44: E5 09    | _func_equals       // =           // b a b=[a]
0C46: 7D 05    | _func_qbranch      // (?branch)   // IF b!=[a] GOTO 0x0C50
0C48: 50 0C    | 0x0C50             //     0x0C50
0C4A: D1 08    | _func_oneplus      // 1+          // b a+1
0C4C: 6B 05    | _func_branch       // (branch)    // GOTO 0x0C3B
0C4E: 3E 0C    | 0x0C3E             //     0x0C3E

0C50: 18 07    | _func_TUCK         // TUCK        // a* b a*
0C52: B3 06    | _func_OVER         // OVER        // a* b a* b
0C54: B3 06    | _func_OVER         // OVER        // a* b a* b a*
0C56: 7F 07    | _func_Cat          // C@          // a* b a* b [a*]
0C58: 48 09    | _func_ltgt         // <>          // a* b a* b!=[a*]
0C5A: B3 06    | _func_OVER         // OVER        // a* b a* b!=[a*] a*
0C5C: 7F 07    | _func_Cat          // C@          // a* b a* b!=[a*] [a*]
0C5E: 26 09    | _func_zeroltgt     // 0<>         // a* b a* b!=[a*] [a*]!=0
0C60: 86 08    | _func_AND          // AND         // a* b a* (b!=[a*])&([a*]!=0)
0C62: 7D 05    | _func_qbranch      // (?branch)   // IF (b=[a])|([a]=0) GOTO 0x0C6C
0C64: 6C 0C    | 0x0C6C             //     0x0C6C
0C66: D1 08    | _func_oneplus      // 1+          // a* b a*+1
0C68: 6B 05    | _func_branch       // (branch)    // GOTO 0x0C52
0C6A: 52 0C    | 0x0C52             //     0x0C52

0C6C: 49 06    | _func_DUP          // DUP         // a* b a^ a^
0C6E: 7F 07    | _func_Cat          // C@          // a* b a^ [a^]
0C70: 7D 05    | _func_qbranch      // (?branch)   // IF [a^]=0 GOTO 0x0C7E
0C72: 7E 0C    | 0x0C7E             //     0x0C7E
0C74: 50 05    | _func_lit          // (lit)       // a* b a^ 0
0C76: 00 00    | 0x0000             //     0x0000
0C78: B3 06    | _func_OVER         // OVER        // a* b a^ 0 a^
0C7A: 64 07    | _func_Cexclamation // C!          // a* b a^
0C7C: D1 08    | _func_oneplus      // 1+          // a* b a^+1
0C7E: 0B 07    | _func_NIP          // NIP         // a* (a^+1)|a^
0C80: 8D 06    | _func_SWAP         // SWAP        // (a^+1)|a^ a*
0C82: 5C 05    | _func_EXIT         // EXIT

// Performs a C-style strcmp operation strcmp(S[1], S[0]), pops both values and pushes the result
0C84: 00
_ascii_STRCMP: | "STRCMP"
0C85: 53 54 52 43 4D 50 00 00 3B 0C
_func_STRCMP:                             // a b
0C8F: 22 65 06 | ent _func_2DUP // DUP    // 
0C92: A9 0A    | _func_STRLEN   // STRLEN
0C94: 8D 06    | _func_SWAP     // SWAP
0C96: A9 0A    | _func_STRLEN   // STRLEN
0C98: 28 0A    | _func_MIN      // MIN
0C9A: D1 08    | _func_oneplus  // 1+
0C9C: 76 0A    | _func_MEMCMP   // MEMCMP
0C9E: 5C 05    | _func_EXIT     // EXIT

// Pops a character, pushes TRUE if it is a number in the current radix, else pushes FALSE
0CA0: 00
_ascii_ISUNUM: | "ISUNUM"
0CA1: 49 53 55 4E 55 4D 00 00 8F 0C
_func_ISUNUM:
0CAB: 22 49 06 | ent _func_DUP  // DUP
0CAE: 50 05    | _func_lit      // (lit)
0CB0: 40 00    | 0x0040         //     0x0040
0CB2: 74 09    | _func_gt       // >
0CB4: 7D 05    | _func_qbranch  // (?branch)
0CB6: BE 0C    | 0x0CBE         //     0x0CBE
0CB8: 50 05    | _func_lit      // (lit)
0CBA: 07 00    | 0x0007         //     0x0007
0CBC: 9C 07    | _func_minus    // -
0CBE: 50 05    | _func_lit      // (lit)
0CC0: 30 00    | 0x0030         //     0x0030
0CC2: 9C 07    | _func_minus    // -
0CC4: 49 06    | _func_DUP      // DUP
0CC6: 36 09    | _func_zerolt   // 0<
0CC8: 8D 06    | _func_SWAP     // SWAP
0CCA: 2B 0B    | _func_RADIX    // RADIX
0CCC: 73 07    | _func_at       // @
0CCE: DC 08    | _func_oneminus // 1-
0CD0: 74 09    | _func_gt       // >
0CD2: 93 08    | _func_OR       // OR
0CD4: 13 09    | _func_zeroeq   // 0=
0CD6: 5C 05    | _func_EXIT     // EXIT

0CD8: 00
_ascii_ISNUM:  | "ISNUM"
0CD9: 49 53 4E 55 4D 00 00 AB 0C
_func_ISNUM:
0CE2: 22 49 06 | ent _func_DUP // DUP
0CE5: AB 0C    | _func_ISUNUM  // ISUNUM
0CE7: 8D 06    | _func_SWAP    // SWAP
0CE9: 50 05    | _func_lit     // (lit)
0CEB: 2D 00    | 0x002D        //     0x002D
0CED: E5 09    | _func_equals  // =
0CEF: 93 08    | _func_OR      // OR
0CF1: 5C 05    | _func_EXIT    // EXIT

// Pops a string, converts it to an unsigned number and pushes the number
0CF3: 00
_ascii_UATOI:  | "UATOI"
0CF4: 55 41 54 4F 49 00 00 E2 0C
_func_UATOI:
0CFD: 22 50 05 | ent _func_lit  // (lit)
0D00: 00 00    | 0x0000         //     0x0000
0D02: B3 06    | _func_OVER     // OVER
0D04: 7F 07    | _func_Cat      // C@
0D06: 49 06    | _func_DUP      // DUP
0D08: 50 05    | _func_lit      // (lit)
0D0A: 40 00    | 0x0040         //     0x0040
0D0C: 74 09    | _func_gt       // >
0D0E: 7D 05    | _func_qbranch  // (?branch)
0D10: 18 0D    | 0x0D18         //     0x0D18
0D12: 50 05    | _func_lit      // (lit)
0D14: 07 00    | 0x0007         //     0x0007
0D16: 9C 07    | _func_minus    // -
0D18: 50 05    | _func_lit      // (lit)
0D1A: 30 00    | 0x0030         //     0x0030
0D1C: 9C 07    | _func_minus    // -
0D1E: 49 06    | _func_DUP      // DUP
0D20: 36 09    | _func_zerolt   // 0<
0D22: B3 06    | _func_OVER     // OVER
0D24: 2B 0B    | _func_RADIX    // RADIX
0D26: 73 07    | _func_at       // @
0D28: CE 09    | _func_ltequals // <=
0D2A: 93 08    | _func_OR       // OR
0D2C: 13 09    | _func_zeroeq   // 0=
0D2E: 7D 05    | _func_qbranch  // (?branch)
0D30: 46 0D    | 0x0D46         //     0x0D46
0D32: 8D 06    | _func_SWAP     // SWAP
0D34: 2B 0B    | _func_RADIX    // RADIX
0D36: 73 07    | _func_at       // @
0D38: DB 07    | _func_Ustar    // U*
0D3A: 8F 07    | _func_plus     // +
0D3C: 8D 06    | _func_SWAP     // SWAP
0D3E: D1 08    | _func_oneplus  // 1+
0D40: 8D 06    | _func_SWAP     // SWAP
0D42: 6B 05    | _func_branch   // (branch)
0D44: 02 0D    | 0x0D02         //     0x0D02
0D46: 75 06    | _func_DROP     // DROP
0D48: 0B 07    | _func_NIP      // NIP
0D4A: 5C 05    | _func_EXIT     // EXIT

0D4C: 00
_ascii_ATOI:   | "ATOI"
0D4D: 41 54 4F 49 00 00 FD 0C
_func_ATOI
0D55: 22 49 06 | ent _func_DUP // DUP
0D58: 7F 07    | _func_Cat     // Cat
0D5A: 50 05    | _func_lit     // (lit)
0D5C: 2D 00    | 0x002D        //     0x002D
0D5E: E5 09    | _func_equals  // =
0D60: 7D 05    | _func_qbranch // (?branch)
0D62: 6E 0D    | 0x0D6E        //     0x0D6E
0D64: D1 08    | _func_oneplus // 1+
0D66: FD 0C    | _func_UATOI   // UATOI
0D68: C3 08    | _func_NEGATE  // NEGATE
0D6A: 6B 05    | _func_branch  // (branch)
0D6C: 70 0D    | 0x0D70        //     0x0D70
0D6E: FD 0C    | _func_UATOI   // UATOI
0D70: 5C 05    | _func_EXIT    // EXIT

0D72: 00
_ascii_HEX:
0D73: 48 45 58 00 01 55 0D
_func_HEX:
0D7A: 22 50 05 | ent _func_lit     // (lit)
0D7D: 10 00    | 0x0010            //     0x0010
0D7F: 2B 0B    | _func_RADIX       // RADIX
0D81: 38 07    | _func_exclamation // !
0D83: 5C 05    | _func_EXIT        // EXIT

0D85: 00
_ascii_DECIMAL:
0D86: 44 45 43 49 4D 41 4C 00 01 7A 0D
_func_DECIMAL:
0D91: 22 50 05 | ent _func_lit     // (lit)
0D94: 0A 00    | 0x000A            //     0x000A
0D96: 2B 0B    | _func_RADIX       // RADIX
0D98: 38 07    | _func_exclamation // !
0D9A: 5C 05    | _func_EXIT        // EXIT

// Waits until the next tick
0D9C: 00
_ascii_TICK:     | "TICK"
0D9D: 54 49 43 4B 00 00 91 0D
_func_TICK:
0DA5: CB         | wai
0DA6: 02         | nxt

// Pops a value and sets the current Redbus device to it
0DA7: 00
_ascii_RBPexclamation: | "RBP!"
0DA8: 52 42 50 21 00 00 A5 0D
_func_RBPexclamation:
0DB0: 68        | pla
0DB1: EF 00     | mmu 0x00
0DB3: 02        | nxt

0DB4: 00
_ascii_TERMADDR: | "TERMADDR"
0DB5: 54 45 52 4D 41 44 44 52 00 00 B0 0D
_func_TERMADDR:
0DC1: 22 34 05 | ent _func_DOVAR
_var_TERMADDR:
0DC4: 01 00    | 1      // Terminal device

0DC6: 00
_ascii_PAGE:   | "PAGE"
0DC7: 50 41 47 45 00 00 C1 0D
0DCF: 22 C1 0D | ent _func_TERMADDR   // TERMADDR
0DD2: 73 07    | _func_at             // @
0DD4: B0 0D    | _func_RBPexclamation // RBP!
0DD6: 50 05    | (lit)                // (lit)
0DD8: 00 00    | 0x0000               //     0x0000
0DDA: 50 05    | (lit)
0DDC: 03 03    | 0x0303
0DDE: 64 07    | _func_Cexclamation
0DE0: 50 05    | (lit)
0DE2: 20 00    | 0x0020
0DE4: 50 05    | (lit)
0DE6: 08 03    | 0x0308
0DE8: 64 07    | _func_Cexclamation
0DEA: 50 05    | (lit)
0DEC: 00 00    | 0x0000
0DEE: 50 05    | (lit)
0DF0: 0A 03    | 0x030A
0DF2: 38 07    | _func_exclamation
0DF4: 50 05    | (lit)
0DF6: 50 32    | 0x3250
0DF8: 50 05    | (lit)
0DFA: 0C 03    | 0x030C
0DFC: 38 07    | _func_exclamation
0DFE: 50 05    | (lit)
0E00: 01 00    | 0x0001
0E02: 50 05    | (lit)
0E04: 07 03    | 0x0307
0E06: 64 07    | _func_Cexclamation
0E08: 50 05    | (lit)
0E0A: 07 03    | 0x0307
0E0C: 7F 07    | _func_Cat
0E0E: 13 09    | _func_zeroeq
0E10: A5 0D    | _func_TICK
0E12: 7D 05    | _func_qbranch
0E14: 08 0E    | 0x0E08
0E16: 50 05    | (lit)
0E18: 01 00    | 0x0001
0E1A: 50 05    | (lit)
0E1C: 01 03    | 0x0301
0E1E: 38 07    | _func_exclamation
0E20: 50 05    | (lit)
0E22: 02 00    | 0x0002
0E24: 50 05    | (lit)
0E26: 03 03    | 0x0303
0E28: 64 07    | _func_Cexclamation
0E2A: 5C 05    | _func_EXIT

// Scrolls the screen by one line
0E2C: 00
_ascii_SCROLL: | "SCROLL"
0E2D: 53 43 52 4F 4C 4C 00 00 CF 0D
_func_SCROLL:
0E37: 22 C1 0D | ent _func_TERMADDR   // TERMADDR   // Select terminal
0E3A: 73 07    | _func_at             // @
0E3C: B0 0D    | _func_RBPexclamation // RBP!
0E3E: 50 05    | _func_lit            // (lit)      // Cursor mode = hidden
0E40: 00 00    | 0x0000               //     0x0000
0E42: 50 05    | _func_lit            // (lit)
0E44: 03 03    | 0x0303               //     0x0303
0E46: 64 07    | _func_Cexclamation   // C!
0E48: 50 05    | _func_lit            // (lit)      // Blit start X = 0
0E4A: 00 01    | 0x0001               //     0x0001
0E4C: 50 05    | _func_lit            // (lit)
0E4E: 08 03    | 0x0308               //     0x0308
0E50: 38 07    | _func_exclamation    // C!
0E52: 50 05    | _func_lit            // (lit)      // Blit X,Y offset = 0
0E54: 00 00    | 0x0000               //     0x0000
0E56: 50 05    | _func_lit            // (lit)
0E58: 0A 03    | 0x030A               //     0x030A
0E5A: 38 07    | _func_exclamation    // !
0E5C: 50 05    | _func_lit            // (lit)      // Blit width = 5, height = 0x30
0E5E: 50 31    | 0x3105               //     0x3105
0E60: 50 05    | _func_lit            // (lit)
0E62: 0C 03    | 0x30C                //     0x030C
0E64: 38 07    | _func_exclamation    // !
0E66: 50 05    | _func_lit            // (lit)      // Blit mode = shift
0E68: 03 00    | 0x0003               //     0x0003
0E6A: 50 05    | _func_lit            // (lit)
0E6C: 07 03    | 0x0307               //     0x0307
0E6E: 64 07    | _func_Cexclamation   // C!
0E70: 50 05    | _func_lit            // (lit)      // Loop while blit mode != 0
0E72: 07 03    | 0x0307               //     0x0307
0E74: 7F 07    | _func_Cat            // C@
0E76: 13 09    | _func_zeroeq         // 0=
0E78: A5 0D    | _func_TICK           // TICK
0E7A: 7D 05    | _func_qbranch        // (?branch)
0E7C: 70 0E    | 0x0E70               //     0x0E70
0E7E: 50 05    | _func_lit            // (lit)      // Blit start X = 0x20
0E80: 20 00    | 0x0020               //     0x0020
0E82: 50 05    | _func_lit            // (lit)
0E84: 08 03    | 0x0308               //     0x0308
0E86: 64 07    | _func_Cexclamation   // C!
0E88: 50 05    | _func_lit            // (lit)      // Blit X offset = 0, Y offset = 0x31
0E8A: 00 31    | 0x3100               //     0x3100
0E8C: 50 05    | _func_lit            // (lit)
0E8E: 0A 03    | 0x030A               //     0x030A
0E90: 38 07    | _func_exclamation    // !
0E92: 50 05    | _func_lit            // (lit)      // Blit width = 0x50, height = 0x01
0E94: 50 01    | 0x0150               //     0x0150
0E96: 50 05    | _func_lit            // (lit)
0E98: 0C 03    | 0x030C               //     0x030C
0E9A: 38 07    | _func_exclamation    // !
0E9C: 50 05    | _func_lit            // (lit)      // Blit mode = fill
0E9E: 01 00    | 0x0001               //     0x0001
0EA0: 50 05    | _func_lit            // (lit)
0EA2: 07 03    | 0x0307               //     0x0307
0EA4: 64 07    | _func_Cexclamation   // C!
0EA6: 50 05    | _func_lit            // (lit)      // Loop while blit mode != 0
0EA8: 07 03    | 0x0307               //     0x0307
0EAA: 7F 07    | _func_Cat            // C@
0EAC: 13 09    | _func_zeroeq         // 0=
0EAE: A5 0D    | _func_TICK           // TICK
0EB0: 7D 05    | _func_qbranch        // (?branch)
0EB2: A6 0E    | 0x0EA6               //     0x0EA6
0EB4: 50 05    | _func_lit            // (lit)      // Cursor mode = blink
0EB6: 02 00    | 0x0002               //     0x0002
0EB8: 50 05    | _func_lit            // (lit)
0EBA: 03 03    | 0x0303               //     0x0303
0EBC: 64 07    | _func_Cexclamation   // C!
0EBE: 5C 05    | _func_EXIT           // EXIT

0EC0: 00
_ascii_CR:     | "CR"
0EC1: 43 52 00 00 37 0E
_func_CR:
0EC7: 22 C1 0D | ent _func_TERMADDR   // TERMADDR   // Select terminal
0ECA: 73 07    | _func_at             // @
0ECC: B0 0D    | _func_RBPexclamation // RBP!
0ECE: 50 05    | _func_lit            // (lit)      // Get cursor Y
0ED0: 02 03    | 0x0302               //     0x0302
0ED2: 7F 07    | _func_Cat            // C@
0ED4: 50 05    | _func_lit            // (lit)
0ED6: 30 00    | 0x0030               //     0x0030
0ED8: 74 09    | _func_gt             // >
0EDA: 7D 05    | _func_qbranch        // (?branch) // If not greater than 48
0EDC: E4 0E    | 0x0EE4               //     0x0EE4
0EDE: 37 0E    | _func_SCROLL         // SCROLL    // Else scroll and branch
0EE0: 6B 05    | _func_branch         // (branch)
0EE2: F2 0E    | 0x0EF2               //     0x0EF2
0EE4: 50 05    | _func_lit            // (lit)     // Increment cursor Y
0EE6: 02 03    | 0x0302               //     0x0302
0EE8: 7F 07    | _func_Cat            // C@
0EEA: D1 08    | _func_oneplus        // 1+
0EEC: 50 05    | _func_lit            // (lit)
0EEE: 02 03    | 0x0302               //     0x0302
0EF0: 64 07    | _func_Cexclamation   // C!
0EF2: 50 05    | _func_lit            // (lit)      // Set cursor X to 0
0EF4: 00 00    | 0x0000               //     0x0000
0EF6: 50 05    | _func_lit            // (lit)
0EF8: 01 03    | 0x0301               //     0x0301
0EFA: 64 07    | _func_Cexclamation   // C!
0EFC: 5C 05    | _func_EXIT           // EXIT

0EFE: 00
_ascii_EMIT:   | "EMIT"
0EFF: 45 4D 49 54 00 00 C7 0E
_func_EMIT:
0F07: 22 C1 0D | ent _func_TERMADDR   // TERMADDR   // Select terminal
0F0A: 73 07    | _func_at             // @
0F0C: B0 0D    | _func_RBPexclamation // RBP!
0F0E: 50 05    | (lit)                // (lit)      // Read cursor Y
0F10: 02 03    | 0x0302               //     0x0302
0F12: 7F 07    | _func_Cat            // C@
0F14: 50 05    | (lit)                // (lit)      // Select memory access row
0F16: 00 03    | 0x0300               //     0x0300
0F18: 64 07    | _func_Cexclamation   // C!
0F1A: 50 05    | (lit)                // (lit)      // Increment cursor X
0F1C: 01 03    | 0x0301               //     0x0301
0F1E: 7F 07    | _func_Cat            // C@
0F20: 50 05    | (lit)                // (lit)
0F22: 10 03    | 0x0301               //     0x0301
0F24: 8F 07    | _func_plus           // +
0F26: 64 07    | _func_Cexclamation   // C!
0F28: 50 05    | (lit)                // (lit)      // IF Cursor X > 78 GOTO 0x0F3E
0F2A: 01 03    | 0x0301               //     0x0301
0F2C: 7F 07    | _func_Cat            // C@
0F2E: 50 05    | (lit)                // (lit)
0F30: 4E 00    | 0x004E               //     0x004E
0F32: 74 09    | _func_gt             // >
0F34: 7D 05    | _func_qbranch        // (?branch)
0F36: 3E 0F    | 0x0F3E               //     0x0F3E
0F38: C7 0E    | _func_CR             // CR         // New line
0F3A: 6B 05    | _func_branch         // (branch)
0F3C: 4C 0F    | 0x0F4C               //     0x0F4C // GOTO 0xF4C
0F3E: 50 05    | (lit)                // (lit)      // Increment cursor X
0F40: 01 03    | 0x0301               //     0x0301
0F42: 7F 07    | _func_Cat            // C@
0F44: D1 08    | _func_oneplus        // 1+
0F46: 50 05    | (lit)                // (lit)
0F48: 01 03    | 0x0301               //     0x0301
0F4A: 64 07    | _func_Cexclamation   // C!
0F4C: 5C 05    | _func_EXIT           // EXIT


0F4E: 00
_ascii_BS:
0F4F: 42 53 00 00 07 0F
_func_BS:
0F55: E2 20    | sep 0x20
0F57: AD C4 0D | lda [_var_TERMADDR]
0F5A: EF 00    | mmu 0x00
0F5C: AD 01 03 | lda [0x0301]
0F5F: F0 10    | beq 0x10
0F61: 3A       | dec A
0F62: 8D 01 03 | sta [0x0301]
0F65: AA       | tax
0F66: AD 02 03 | lda [0x0302]
0F69: 8D 00 03 | sta [0x0300]
0F6C: A9 20 9D | lda 0x9D20
0F6F: 10 03    | bpl 0x03
0F71: C2 20    | rep 0x20
0F73: 02       | nxt

// Tests if a character is available in the key buffer, pushes 0xFFFF if true, else pushes 0x0000
0F74: 00
_ascii_KEYquestion: | "KEY?"
0F75: 4B 45 59 3F 00 00 55 0F
_func_KEYquestion:
0F7D: E2 20    | sep 0x20
0F7F: AD C4 0D | lda [_var_TERMADDR]
0F82: EF 00    | mmu 0x00
0F84: AD 04 03 | lda [0x0304]
0F87: CD 05 03 | cmp [0x0305]
0F8A: C2 20    | rep 0x20
0F8C: F0 04    | beq 0x04
0F8E: F4 FF FF | pea 0xFFFF
0F91: 02       | nxt
0F92: F4 00 00 | pea 0x0000
0F95: 02       | nxt

// Reads a single key from the key buffer, waiting if none is pressed. Pushes the ascii value
0F96: 00
_ascii_KEY:    | "KEY"
0F97: 4B 45 59 00 00 7D 0F
_func_KEY:
0F9E: E2 20    | sep 0x20
0FA0: AD C4 0D | lda [_var_TERMADDR]
0FA3: EF 00    | mmu 0x00
0FA5: AD 04 03 | lda [0x0304]
0FA8: CD 05 03 | cmp [0x0305]
0FAB: D0 03    | bne 0x03
0FAD: CB 80 F5 | wai
0FB0: AD 06 03 | lda [0x0306]
0FB3: 8F       | zea
0FB4: EE 04 03 | inc [0x0304]
0FB7: C2 20    | rep 0x20
0FB9: 48       | pha
0FBA: 02       | nxt

// Pops a value and sets the cursor Y position, then pops a value and sets the cursor X position
0FBB: 00
_ascii_ATdashXY: | "AT-XY"
0FBC: 41 54 2D 58 59 00 00 9E 0F
0FC5: E2 20    | sep 0x20
0FC7: AD C4 0D | lda [_var_TERMADDR]
0FCA: EF 00    | mmu 0x00
0FCC: FA       | plx
0FCD: 8A       | txa
0FCE: 8D 02 03 | sta [0x0302]
0FD1: FA       | plx
0FD2: 8A       | txa
0FD3: 8D 01 03 | sta[ 0x0301]
0FD6: C2 20    | rep 0x20
0FD8: 02       | nxt

// Prints a string literal in the call list
0FD9: 00
_ascii_lpdotquoterp: "(.\")"
0FDA: 28 2E 22 29 00 00 C5 0F
_func_lpdotquoterp:
0FE2: 22 2F 07 | ent _func_Rgt // R>         // Pop return index to value stack
0FE5: 49 06    | _func_DUP     // DUP
0FE7: 7F 07    | _func_Cat     // C@         // Read a character
0FE9: 56 06    | _func_qDUP    // ?DUP
0FEB: 7D 05    | _func_qbranch // (?branch)  // Jump to end if NUL
0FED: F7 0F    | 0x0FF7        //     0x0FF7
0FEE: 07 0F    | _func_EMIT    // EMIT       // Print character, increment index, and loop
0FF1: D1 08    | _func_oneplus // 1+
0FF3: 6B 05    | _func_branch  // (branch)
0FF5: E5 0F    | 0x0FE5        //     0x0FE5
0FF7: D1 08    | _func_oneplus // 1+         // Increment past NUL, push new return index
0FF9: 25 07    | _func_gtR     // >R
0FFB: 5C 05    | _func_EXIT    // EXIT

// Prints a space
0FFD: 00
_ascii_SPACE:  | "SPACE"
0FFE: 53 50 41 43 45 00 00 E2 0F
_func_SPACE:
1007: 22 37 0B | ent _func_BL // BL
100A: 07 0F    | _func_EMIT   // EMIT
100C: 5C 05    | _func_EXIT   // EXIT

// Pops a string address off the stack and prints it
100E: 00
_ascii_TYPE:   | "TYPE"
100F: 54 59 50 45 00 00 07 10
_func_TYPE:
1017: 22 49 06 | ent _func_DUP // DUP
101A: 7F 07    | _func_Cat     // C@
101C: 56 06    | _func_qDUP    // ?DUP
101E: 7D 05    | _func_qbranch // (?branch)
1020: 2A 10    | 0x102A        //     0x102A
1022: 07 0F    | _func_EMIT    // EMIT
1024: D1 08    | _func_oneplus // 1+
1026: 6B 05    | _func_branch  // (branch)
1028: 18 10    | 0x1018        //     0x1018
102A: 75 06    | _func_DROP    // DROP
102C: 5C 05    | _func_EXIT    // EXIT

// Pops a number off the stack and prints it
102E: 00
_ascii_dot:    | "."
102F: 2E 00 00 17 10
1034: 22 49 06 | ent _func_DUP      // DUP
1037: 36 09    | _func_zerolt       // 0<
1039: 7D 05    | _func_qbranch      // (?branch)
103B: 4F 10    | 0x104F             //     0x104F
103D: C3 08    | _func_NEGATE       // NEGATE
103F: 46 0B    | _func_UITOA        // UITOA
1041: DC 08    | _func_oneminus     // 1-
1043: 50 05    | _func_lit          // (lit)
1045: 2D 00    | 0x002D             //     0x002D
1047: B3 06    | _func_OVER         // OVER
1049: 64 07    | _func_Cexclamation // C!
104B: 6B 05    | _func_branch       // (branch)
104D: 51 10    | 0x1051             //     0x1051
104F: 46 0B    | _func_UITOA        // UITOA
1051: 17 10    | _func_TYPE         // TYPE
1053: 07 10    | _func_SPACE        // SPACE
1055: 5C 05    | _func_EXIT         // EXIT

// Pops an unsigned number off the stack and prints it
1057: 00
_ascii_Udot:   | "U."
1058: 55 2E 00 00 34 10
_func_Udot:
105E: 22 46 0B | ent _func_UITOA // UITOA
1061: 17 10    | _func_TYPE      // TYPE
1063: 07 10    | _func_SPACE     // SPACE
1065: 5C 05    | _func_EXIT      // EXIT

1067: 00
_ascii_slashMOD: | "/MOD"
0168: 2F 4D 4F 44 00 00 5E 10
                                            // x y
1070: 22 B3 06 | ent _func_OVER   // OVER   // x y x
1073: 36 09    | _func_zerolt     // 0<     // x y 0<x
1075: 8D 06    | _func_SWAP       // SWAP   // x 0<x y
1077: 05 08    | _func_FMslashMOD // FM/MOD // r q
1079: 5C 05    | _func_EXIT       // EXIT

107B: 00
_ascii_slash:  | "/"
107C: 2F 00 00 70 10
                                            // x y
1081: 22 70 10 | ent _func_slashMOD // /MOD // r q
1084: 75 06    | _func_DROP         // DROP // r q
1086: 5C 05    | _func_EXIT         // EXIT

1088: 00
_ascii_mod:    | "MOD"
1089: 4D 4F 44 00 00 81 10
1090: 22 70 10 | ent _func_slashMOD // /MOD
1093: 0B 07    | _func_NIP          // NIP
1095: 5C 05    | _func_EXIT         // EXIT

1097: 00
_ascii_ABORT:  | "ABORT"
1098: 41 42 4F 52 54 00 00 90 10
10A1: 22 78 16 | ent _func_SP0       // SP0
10A4: F3 08    | _func_SPexclamation // !
10A6: 29 18    | _func_QUIT          // QUIT

10A8: 00
_ascii_TIBPTR: | "TIBPTR"
10A9: 54 49 42 50 54 52 00 00 A1 10 
_func_TIBPTR
10B3: 22 34 05 | ent _func_DOVAR
10B6: 00 00    |             // TIBPTR value

10B8: 00
_ascii_VOCAB:  | "VOCAB"
10B9: 56 4F 43 41 42 00 00 B3 10
_func_VOCAB:
10C2: 22 34 05 | ent _func_DOVAR
_var_VOCAB:
10C5: 56 1D    | _func_COLD  // VOCAB value

10C7: 00
_ascii_lpHERErp: | "(HERE)"
10C8: 28 48 45 52 45 29 00 00 C2 10
_func_lpHERErp:
10D2: 22 34 05 | ent _func_DOVAR
10D5: A7 1D    | _var_HERE   // HERE address

10D7: 00
_ascii_HERE:   | "HERE"
10D8: 48 45 52 45 00 00 D2 10
_func_HERE:
10E0: 22 D2 10 | ent _func_lpHERErp // (HERE)
10E3: 73 07    | _func_at           // @
10E5: 5C 05    | _func_EXIT         // EXIT

10E7: 00
_ascii_TO:     | "TOP"
10E8: 54 4F 50 00 00 E0 10
_func_TOP:
10EF: 22 34 05 | ent _func_DOVAR
_var_TOP:
10F2: 00 00    |             // TOP value

10F4: 00
_ascii_STATE:  | "STATE"
10F5: 53 54 41 54 45 00 00 EF 10
_func_STATE:
10FE: 22 34 05 | ent _func_DOVAR
_var_STATE:
1101: 00 00    |             // STATE value

// Computes the amount of free memory
1103: 00
_ascii_PROBE:  | "PROBE"
1104: 50 52 4F 42 45 00 00 FE 10
_func_PROBE:
110D: 22 50 05 | ent _func_lit      // (lit)      // x1FFF
1110: FF 1F    | 0x1FFF             //     0x1FFF
1112: 49 06    | _func_DUP          // DUP        // x1FFF x1FFF
1114: 50 05    | _func_lit          // (lit)      // x1FFF x1FFF x2000
1116: 00 20    | 0x2000             //     0x2000
1118: 8F 07    | _func_plus         // +          // x1FFF x3FFF
111A: 49 06    | _func_DUP          // DUP        // x1FFF x3FFF x3FFF
111C: 7F 07    | _func_Cat          // C@         // x1FFF x3FFF C[x3FFF]
111E: 49 06    | _func_DUP          // DUP        // x1FFF x3FFF C[x3FFF] C[x3FFF]
1120: B2 08    | _func_INVERT       // INVERT     // x1FFF x3FFF C[x3FFF] ~C[x3FFF]
1122: C1 06    | _func_2OVER        // 2OVER      // x1FFF x3FFF C[x3FFF] ~C[x3FFF] x3FFF
1124: 38 07    | _func_exclamation  // !          // x1FFF x3FFF C[x3FFF]
1126: 49 06    | _func_DUP          // DUP        // x1FFF x3FFF C[x3FFF] C[x3FFF]
1128: C1 06    | _func_2OVER        // 2OVER      // x1FFF x3FFF C[x3FFF] C[x3FFF] x3FFF
112A: 7F 07    | _func_Cat          // C@         // x1FFF x3FFF C[x3FFF] C[x3FFF] C*[x3FFF]
112C: E5 09    | _func_equals       // =          // x1FFF x3FFF C[x3FFF] C[x3FFF]=C*[x3FFF]
112E: 8D 06    | _func_SWAP         // SWAP       // x1FFF x3FFF C[x3FFF]=C*[x1FFF] C[x3FFF]
1130: C1 06    | _func_2OVER        // 2OVER      // x1FFF x3FFF C[x3FFF]=C*[x1FFF] C[x3FFF] x3FFF
1132: 64 07    | _func_Cexclamation // C!         // x1FFF x3FFF C[x3FFF]=C*[x1FFF]
1134: 7D 05    | _func_qbranch      // (?branch)
1136: 3C 11    | 0x113C             //     0x113C
1138: 75 06    | _func_DROP         // DROP       // x1FFF
113A: 5C 05    | _func_EXIT         // EXIT       //

113C: 0B 07    | _func_NIP          // NIP        // x3FFF
113E: 49 06    | _func_DUP          // DUP        // x3FFF x3FFF
1140: 50 05    | _func_lit          // (lit)      // x3FFF x3FFF xFFFF
1142: FF FF    | 0xFFFF             //     0xFFFF
1144: E5 09    | _func_equals       // =          //
1146: 7D 05    | _func_qbranch      // (?branch)
1148: 12 11    | 0x1112             //     0x1112
114A: 5C 05    | _func_EXIT         // EXIT

// Pushes the amount of free memory available
114C: 00
_ascii_FREE:   | "FREE"
114D: 46 52 45 45 00 00 0D 11
_func_FREE:
1155: 22 EF 10 | ent _func_TOP // TOP
1158: 73 07    | _func_at      // @
115A: E0 10    | _func_HERE    // HERE
115C: 9C 07    | _func_minus   // -
115E: 5C 05    | _func_EXIT    // EXIT

1160: 00
_ascii_ALLOT:  | "ALLOT"
1161: 41 4C 4C 4F 54 00 00 55 11
116A: 22 49 06 | ent _func_DUP          // DUP
116D: 50 05    | _func_lit              // (lit)
116F: 02 00    | 0x0002                 //     0x0001
1171: 8F 07    | _func_plus             // +
1173: 55 11    | _func_FREE             // FREE
1175: A2 09    | _func_Ugt              // U>

1177: 7D 05    | _func_qbranch          // (?branch)
1179: 8F 11    | 0x118F                 //     0x118F
117B: E2 0F    | _func_lpdotquoterp     // (.")
_str_OutOfMem: "Out of memory\0"
117D: 4F 75 74 20 6F 66 20 6D 65 6D 6F 72 79 00
118B: C7 0E    | _func_CR               // CR
118D: A1 10    | _func_ABORT            // ABORT

118F: E0 10    | _func_HERE             // HERE
1191: 8D 06    | _func_SWAP             // SWAP
1193: D2 10    | _func_lpHERErp         // (HERE)
1195: 44 07    | _func_plus_exclamation // +!
1197: 5C 05    | _func_EXIT             // EXIT

1199: 00
_ascii_comma:  | ","
119A: 2C 00 00 6A 11
_func_comma:
119F: 22 FD 09 | ent _func_CELL    // CELL
11A2: 6A 11    | _func_ALLOT       // ALLOT
11A4: 38 07    | _func_exclamation // !
11A6: 5C 05    | _func_EXIT        // EXIT

11A8: 00
_ascii_commaC: | ",C"
11A9: 2C 43 00 00 9F 11
_func_commaC:
11AF: 22 50 05 | ent _func_lit      // (lit)
11B2: 01 00    | 0x0001             //     0x0001
11B4: 6A 11    | _func_ALLOT        // ALLOT
11B6: 64 07    | _func_Cexclamation // C!
11B8: 5C 05    | _func_EXIT         // EXIT

11BC: 00
_ascii_commaS: | ",S"
11BD: 2C 53 00 00 AF 11
_func_commaS:
11C1: 22 49 06 | ent _func_DUP // DUP
11C4: 7F 07    | _func_Cat     // C@
11C6: 7D 05    | _func_qbranch // (?branch)
11C8: D6 11    | 0x11D6        //     0x11D6
11CA: 49 06    | _func_DUP     // DUP
11CC: 7F 07    | _func_Cat     // C@
11CE: AF 11    | _func_commaC  // ,C
11D0: D1 08    | _func_oneplus // 1+
11D2: 6B 05    | _func_branch  // (branch)
11D4: C2 11    | 0x11C2        //     0x11C2
11D6: 75 06    | _func_DROP    // DROP
11D8: 50 05    | _func_lit     // (lit)
11DA: 00 00    | 0x0000        // 0x0000
11DC: AF 11    | _func_commaC  // ,C
11DE: 5C 05    | _func_EXIT    // EXIT

11E0: 00
_ascii_TIBWORD: | "TIBWORD"
11E1: 54 49 42 57 4F 52 44 00 00 C1 11
_func_TIBWORD:
11EC: 22 B3 10 | ent _func_TIBPTR  // TIBPTR
11EF: 73 07    | _func_at          // @
11F1: 98 0B    | _func_WORD        // WORD
11F3: 8D 06    | _func_SWAP        // SWAP
11F5: B3 10    | _func_TIBPTR      // TIBPTR
11F7: 38 07    | _func_exclamation // !
11F9: 5C 05    | _func_EXIT        // EXIT

11FB: 00
_ascii_TIBSPLIT: | "TIBSPLIT"
11FC: 54 49 42 53 50 4C 49 54 00 00 EC 11
_func_TIBSPLIT:
1208: 22 B3 10 | ent _func_TIBPTR  // TIBPTR
120B: 73 07    | _func_at          // @
120D: 8D 06    | _func_SWAP        // SWAP
120F: 3B 0C    | _func_SPLIT       // SPLIT
1211: 8D 06    | _func_SWAP        // SWAP
1213: B3 10    | _func_TIBPTR      // TIBPTR
1215: 38 07    | _func_exclamation // !
1217: 5C 05    | _func_EXIT        // EXIT

1219: 00
_ascii_HEADER: | "HEADER"
121A: 48 45 41 44 45 52 00 00 08 12
_func_HEADER:
1224: 22 50 05 | ent _func_lit     // (lit)
1227: 00 00    | 0x0000            //     0x0000
1229: AF 11    | _func_commaC      // ,C
122B: EC 11    | _func_TIBWORD     // TIBWORD
122D: C1 11    | _func_commaS      // ,S
122F: 50 05    | _func_lit         // (lit)
1231: 00 00    | 0x0000            //     0x0000
1233: AF 11    | _func_commaC      // ,C
1235: C2 10    | _func_VOCAB       // VOCAB
1237: 73 07    | _func_at          // @
1239: 9F 11    | _func_comma       // ,
123B: E0 10    | _func_HERE        // HERE
123D: C2 10    | _func_VOCAB       // VOCAB
123F: 38 07    | _func_exclamation // !
1241: 5C 05    | _func_EXIT        // EXIT

1243: 00
_ascii_CONSTANT: | "CONSTANT"
1244: 43 4F 4E 53 54 41 4E 54 00 00 24 12
_func_CONSTANT:
1250: 22 24 12 | ent _func_HEADER // HEADER
1253: 50 05    | _func_lit        // (lit)
1255: 22 00    | 0x0022           //     0x0022
1257: AF 11    | _func_commaC     // ,C
1259: 50 05    | _func_lit        // (lit)
125B: 24 05    | _func_DOCON      //     DOCON
125D: 9F 11    | _func_comma      // ,
125F: 9F 11    | _func_comma      // ,
1261: 5C 05    | _func_EXIT       // EXIT

1263: 00
_ascii_CREATE: | "CREATE"
1264: 43 52 45 41 54 45 00 00 50 12
_func_CREATE:
126E: 22 24 12 | ent _func_HEADER // HEADER
1271: 50 05    | _func_lit        // (lit)
1273: 22 00    | 0x0022           //     0x0022
1275: AF 11    | _func_commaC     // ,C
1277: 50 05    | _func_lit        // (lit)
1279: 34 05    | _func_DOVAR      // DOVAR
127B: 9F 11    | _func_comma      // ,
127D: 5C 05    | _func_EXIT       // EXIT

127F: 00
_ascii_VARIABLE: | "VARIABLE"
1280: 56 41 52 49 41 42 4C 45 00 00 6E 12
_func_VARIABLE:
128C: 22 6E 12 | ent _func_CREATE // CREATE
128F: 50 05    | _func_lit        // (lit)
1291: 00 00    | 0x0000           //     0x0000
1293: 9F 11    | _func_comma      // ,
1295: 5C 05    | _func_EXIT       // EXIT

1297: 00
_ascii_lb:     | "["
1298: 5B 00 00 8C 12
_func_lb:
129D: 22 50 05 | ent _func_lit     // (lit)
12A0: 01 00    | 0x0001            //     0x0001
12A2: FE 10    | _func_STATE       // STATE
12A4: 38 07    | _func_exclamation // !
12A6: 5C 05    | _func_EXIT        // EXIT

12A8: 00
_ascii_rb:     | "]"
12A9: 5D 00 01 9D 12
_func_rb:
12AE: 22 50 05 | ent _func_lit     // (lit)
12B1: 00 00    | 0x0000            //     0x0000
12B3: FE 10    | _func_STATE       // STATE
12B5: 38 07    | _func_exclamation // !
12B7: 5C 05    | _func_EXIT        // EXIT

12B9: 00
_ascii_HIDE:   | "HIDE"
12BA: 48 49 44 45 00 00 AE 12
_func_HIDE:
12C2: 22 C2 10 | ent _func_VOCAB    // VOCAB
12C5: 73 07    | _func_at           // @
12C7: 50 05    | _func_lit          // (lit)
12C9: 03 00    | 0x0003             //     0x0003
12CB: 9C 07    | _func_minus        // -
12CD: 49 06    | _func_DUP          // DUP
12CF: 7F 07    | _func_Cat          //  C@
12D1: 50 05    | _func_lit          // (lit)
12D3: 02 00    | 0x0002             //     0x0002
12D5: 93 08    | _func_OR           // OR
12D7: 8D 06    | _func_SWAP         // SWAP
12D9: 64 07    | _func_Cexclamation // C!
12DB: 5C 05    | _func_EXIT         // EXIT

12DD: 00
_ascii_REVEAL: | "REVEAL"
12DE: 52 45 56 45 41 4C 00 00 C2 12
_func_REVEAL:
12E8: 22 C2 10 | ent _func_VOCAB    // VOCAB
12EB: 73 07    | _func_at           // @
12ED: 50 05    | _func_lit          // (lit)
12EF: 03 00    | 0x0003             //     0x0003
12F1: 9C 07    | _func_minus        // -
12F3: 49 06    | _func_DUP          // DUP
12F5: 7F 07    | _func_Cat          // C@
12F7: 50 05    | _func_lit          // (lit)
12F9: 01 00    | 0x0001             //     0x0001
12FB: 86 08    | _func_AND          // AND
12FD: 8D 06    | _func_SWAP         // SWAP
12FF: 64 07    | _func_Cexclamation // C!
1301: 5C 05    | _func_EXIT         // EXIT

1303: 00
_ascii_IMMEDIATE: | "IMMEDIATE"
1304: 49 4D 4D 45 44 49 41 54 45 00 00 E8 12
1311: 22 C2 10 | ent _func_VOCAB    // VOCAB
1314: 73 07    | _func_at           // @
1316: 50 05    | _func_lit          // (lit)
1318: 03 00    | 0x0003             //     0x0003
131A: 9C 07    | _func_minus        // -
131C: 49 06    | _func_DUP          // DUP
131E: 7F 07    | _func_Cat          // C@
1320: 50 05    | _func_lit          // (lit)
1322: 01 00    | 0x0001             //     0x0001
1324: 93 08    | _func_OR           // OR
1326: 8D 06    | _func_SWAP         // SWAP
1328: 64 07    | _func_Cexclamation // C!
132A: 5C 05    | _func_EXIT         // EXIT

// Sets the address of the next word's ENT instruction to the return address
132C: 00
_ascii_lpdoesrp: | "(does)"
132D: 28 64 6F 65 73 29 00 00 11 13
1337: 22 2F 07 | ent _func_Rgt     // R>    // r
133A: C2 10    | _func_VOCAB       // VOCAB // r VOCAB
133C: 73 07    | _func_at          // @     // r [VOCAB]
133E: D1 08    | _func_oneplus     // 1+    // r [VOCAB]+1
1340: 38 07    | _func_exclamation // !     //
1342: 5C 05    | _func_EXIT        // EXIT

// Appends the address after it to the next word
1344: 00
_ascii_DOESgt: | "DOES>"
1345: 44 4F 45 53 3E 00 01 37 13
134E: 22 50 05 | ent _func_lit  // (lit)
1351: 37 13    | _func_lpdoesrp //     _func_lpdoesrp
1353: 9F 11    | _func_comma    // ,
1355: 50 05    | _func_lit      // (lit)
1357: 22 00    | 0x0022         //     0x0022
1359: AF 11    | _func_commaC   // ,C
135B: 50 05    | _func_lit      // (lit)
135D: 43 05    | _func_DODOES   //     _func_DODOES
135F: 9F 11    | _func_comma    // ,
1361: 5C 05    | _func_EXIT     // EXIT

// Begins compiling a word named the next word in the terminal buffer
1363: 00
_ascii_colon:  | ":"
1364: 3A 00 00 4E 13
1369: 22 24 12 | _func_HEADER
136C: C2 12    | _func_HIDE
136E: 50 05    | _func_lit
1370: 22 00    | 0x0022
1372: AF 11    | _func_commaC
1374: 9D 12    | _func_lb
1376: 5C 05    | _func_EXIT

// Ends compiling a word
1378: 00
_ascii_semicolon: | ";"
1379: 3B 00 01 69 13
137E: 22 50 05 | _func_lit
1381: 5C 05    | _func_EXIT
1383: 9F 11    | _func_comma
1385: AE 12    | _func_rb
1387: E8 12    | _func_REVEAL
1389: 5C 05    | _func_EXIT

138B: 00
_ascii_IF:     | "IF"
138C: 49 46 00 01 7E 13
_func_IF:
1392: 22 50 05 | ent _func_lit
1395: 7D 05    | _func_qbranch
1397: 9F 11    | _func_comma
1399: E0 10    | _func_HERE
139B: 50 05    | _func_lit
139D: 00 00    | 0x0000
139F: 9F 11    | _func_comma
13A1: 50 05    | _func_lit
13A3: 00 00    | 0x0000
13A5: 5C 05    | _func_EXIT

13A7: 00
_ascii_THEN:   | "THEN"
13A8: 54 48 45 4E 00 01 92 13
_func_THEN:
13B0: 22 75 06 | ent _func_DROP    // DROP
13B3: E0 10    | _func_HERE        // HERE
13B5: 8D 06    | _func_SWAP        // SWAP
13B7: 38 07    | _func_exclamation // !
13B9: 5C 05    | _func_EXIT        // EXIT

13BB: 00
_ascii_ELSE:   | "ELSE"
13BC: 45 4C 53 45 00 01 B0 13
_func_ELSE:
13C4: 22 75 06 | ent _func_DROP    // DROP
13C7: 50 05    | _func_lit         // (lit)
13C9: 6B 05    | _func_branch      //     (branch)
13CB: 9F 11    | _func_comma       // ,
13CB: E0 10    | _func_HERE        // HERE
13CF: 50 05    | _func_lit         // (lit)
13D1: 00 00    | 0x0000            //     0x0000
13D3: 9F 11    | _func_comma       // ,
13D5: 8D 06    | _func_SWAP        // SWAP
13D7: E0 10    | _func_HERE        // HERE
13D9: 8D 06    | _func_SWAP        // SWAP
13DB: 38 07    | _func_exclamation // !
13DD: 50 05    | _func_lit         // (lit)
13DF: 00 00    | 0x0000            //     0x0000
13E1: 5C 05    | _func_EXIT        // EXIT

13E3: 00
_ascii_dotquote: | ".\""
13F4: 2E 22 00 01 C4 13
_func_dotquote:
14FA: 22 50 05 | _func_lit          // (lit)
13FD: E2 0F    | _func_lpdotquoterp //     (.")
13FF: 9F 11    | _func_comma        // ,
13F1: 50 05    | _func_lit          // (lit)
13F3: 22 00    | 0x0022             //     0x0022
13F5: 08 12    | _func_TIBSPLIT     // TIBSPLIT
13F7: C1 11    | _func_commaS       // ,S
13F9: 5C 05    | _func_EXIT         // EXIT

13FB: 00
_ascii_BEGIN:
13FC: 42 45 47 49 4E 00 01 EA 13
_func_BEGIN:
1405: 22 E0 10 | ent _func_HERE
1408: 50 05    | _func_lit
140A: 00 00    | 0x0000
140C: 5C 05    | _func_EXIT

140E: 00
_ascii_AGAIN:  | "AGAIN"
140F: 41 47 41 49 4E 00 01 05 14
_func_AGAIN:
1418: 22 75 06 | ent _func_DROP
141B: 50 05    | _func_lit
141D: 6B 05    | _func_branch
141F: 9F 11    | _func_comma
1421: 9F 11    | _func_comma
1423: 5C 05    | _func_EXIT

1425: 00
_ascii_UNTIL:  | "UNTIL"
1426: 55 4E 54 49 4C 00 01 18 14
_func_UNTIL:
142F: 22 75 06 | ent _func_DROP
1432: 50 05    | _func_lit
1434: 7D 05    | _func_qbranch
1436: 9F 11    | _func_comma
1438: 9F 11    | _func_comma
143A: 5C 05    | _func_EXIT

143C: 00
_ascii_WHILE:  | "WHILE"
143D: 57 48 49 4C 45 00 01 2F 14
_func_WHILE:
1446: 22 50 05 | ent _func_lit
1449: 7D 05    | _func_qbranch
144B: 9F 11    | _func_comma
144D: E0 10    | _func_HERE
144F: 50 05    | _func_lit
1451: 00 00    | 0x0000
1453: 9F 11    | _func_comma
1455: 50 05    | _func_lit
1457: 00 00    | 0x0000
1459: 5C 05    | _func_EXIT

145B: 00
_ascii_REPEAT: | "REPEAT"
145C: 52 45 50 45 41 54 00 01 46 14
_func_REPEAT:
1466: 22 75 06 | ent _func_DROP
1469: 0B 07    | _func_NIP
146B: 8D 06    | _func_SWAP
146D: 50 05    | _func_lit
146F: 6B 05    | _func_branch
1471: 9F 11    | _func_comma
1473: 9F 11    | _func_comma
1475: E0 10    | _func_HERE
1477: 8D 06    | _func_SWAP
1479: 38 07    | _func_exclamation
147B: 5C 05    | _func_EXIT

147D: 00
_ascii_DO:     | "DO"
147E: 44 4F 00 01 66 14
_func_DO:
1484: 22 50 05 | ent _func_lit
1487: 8D 05    | _func_
1489: 9F 11
148B: E0 10
148D: 50 05
148F: 00 00
1491: 9F 11
1493: E0 10
1495: 8D 06
1497: 5C 05

1499: 00
_ascii_qDO:    | "?DO"
149A: 3F 44 4F 00 01 84 14
_func_qDO:
14A1: 22 50 05
14A4: A2 05
14A6: 9F 11
14A8: E0 10
14AA: 50 05
14AC: 00 00
14AE: 9F 11
14B0: E0 10
14B2: 8D 06
14B4: 5C 05

14B6: 00
_ascii_LOOP:   | "LOOP"
14B7: 4C 4F 4F 50 00 01 A1 14
_func_LOOP:
14BF: 22 8D 06
14C2: 50 05
14C4: BF 05
14C6: 9F 11
14C8: 9F 11
14CA: 50 05
14CC: 14 06
14CE: 9F 11
14D0: E0 10
14D2: 8D 06
14D4: 38 07
14D6: 5C 05

14D8: 00
_ascii_pLOOP:  | "+LOOP"
14D9: 2B 4C 4F 4F 50 00 01 BF 14
_func_qLOOP:
14E2: 22 8D 06
14E5: 50 05
14E7: DE 05
14E9: 9F 11
14EB: 9F 11
14ED: 50 05
14EF: 14 06
14F1: 9F 11
14F3: E0 10
14F5: 8D 06
14F7: 38 07
14F9: 5C 05

14FB: 00
_ascii_LEAVE:  | "LEAVE"
14FC: 4C 45 41 56 45 00 01 E2 14
_func_LEAVE:
1505: 22 50 05
1508: 01 00
150A: 49 06
150C: 9B 06
150E: 13 09
1510: 7D 05
1512: 1E 15
1514: 50 05
1516: 02 00
1518: 8F 07
151A: 6B 05
151C: 0A 15
151E: 50 05
1520: 00 06
1522: 9F 11
1524: 9B 06
1526: 50 05
1528: 02 00
152A: 9C 07
152C: 9F 11
152E: 5C 05

1530: 00
_ascii_backslash: | "\"
1531: 5C 00 01 05 15
_func_backslash:
1536: 22 50 05 | ent _func_lit // (lit)
1539: 0D 00    | 0x000D        //     '\r'
153B: 08 12    | TIBSPLIT      // TIBSPLIT
153D: 75 06    | _func_DROP    // DROP
153F: 5C 05    | _func_EXIT    // EXIT

1541: 00
_ascii_lp:  | "("
1542: 28 00 01 36 15
_func_lp:
1547: 22 50 05 | ent _func_lit // (lit)
154A: 29 00    | 0x0029        //     ')'
154C: 08 12    | TIBSPLIT      // TIBSPLIT
154E: 75 06    | _func_DROP    // DROP
1550: 5C 05    | _func_EXIT    // EXIT

1552: 00
_ascii_lpquoterp: | "(\")"
1553: 28 22 29 00 00 47 15
_func_lpquoterp:
155A: 22 2F 07 | ent _func_Rgt // R>         // r
155D: 49 06    | _func_DUP     // DUP        // r r
155F: 49 06    | _func_DUP     // DUP        // r r *r
1561: 7F 07    | _func_Cat     // C@         // r r C[*r]
1563: 7D 05    | _func_qbranch // (?branch)  // r r
1565: 6D 15    | 0x156D        //     0x156D //
1567: D1 08    | _func_oneplus // 1+         // r r+1
1569: 6B 05    | _func_branch  // (branch)   //
156B: 5F 15    | 0x155F        //     0x155F //
156D: D1 08    | _func_oneplus // 1+         // r r+1
156F: 25 07    | _func_gtR     // >R         // r
1571: 5C 05    | _func_EXIT    // EXIT

1573: 00
_ascii_quote:  | "\""
1574: 22 00 01 5A 15
_func_quote:
1579: 22 50 05 | ent _func_lit   // (lit)
157C: 5A 15    | _func_lpquoterp //     (")
157E: 9F 11    | _func_comma     // ,
1580: 50 05    | _func_lit       // (lit)
1582: 22 00    | 0x0022          //     '\"'
1584: 08 12    | _func_TIBSPLIT  // TIBSPLIT
1586: C1 11    | _func_commaS    // ,S
1588: 5C 05    | _func_EXIT      // EXIT

158A: 00
_ascii_TIMES:  | "TIMES"
158B: 54 49 4D 45 53 00 01 79 15
_func_TIMES:
1594: 22 FE 10 | ent _func_STATE  // STATE
1597: 73 07    | _func_at         // @
1599: 13 09    | _func_zeroeq     // 0=
159B: 7D 05    | _func_qbranch    // (?branch)  // If not interpreting, jump
159D: BB 15    | 0x15BB           //     0x15BB
159F: F1 18    | _func_apostrophe // '
15A1: 8D 06    | _func_SWAP       // SWAP
15A3: 50 05    | _func_lit        // (lit)
15A5: 00 00    | 0x0000           //     0x0000
15A7: A2 05    | _func_qdo        // (?do)
15A9: B5 15    | 0x15B5           //     0x15B5
15AB: 49 06    | _func_DUP        // DUP
15AD: 3D 06    | _func_EXECUTE    // EXECUTE
15AF: BF 05    | _func_loop       // (loop)
15B1: AB 15    | 0x15AB           //     0x15AB
15B3: 14 06    | _func_UNLOOP     // UNLOOP
15B5: 75 06    | _func_DROP       // DROP
15B7: 6B 05    | _func_branch     // (branch)
15B9: F1 15    | 0x15F1           //     0x15F1
15BB: F1 18    | _func_apostrophe // '
15BD: 50 05    | _func_lit        // (lit)
15BF: 50 05    | _func_lit        //     (lit)
15C1: 9F 11    | _func_comma      // ,
15C3: 50 05    | _func_lit        // (lit)
15C5: 00 00    | 0x0000           //     0x0000
15C7: 9F 11    | _func_comma      // ,
15C9: 50 05    | _func_lit        // (lit)
15CB: A2 05    | _func_qdo        //     (?do)
15CD: 9F 11    | _func_comma      // ,
15CF: E0 10    | _func_HERE       // HERE
15D1: 50 05    | _func_lit        // (lit)
15D3: 0A 00    | 0x000A           //     0x000A
15D5: 8F 07    | _func_plus       // +
15D7: 9F 11    | _func_comma      // ,
15D9: 9F 11    | _func_comma      // ,
15DB: E0 10    | _func_HERE       // HERE
15DD: 50 05    | _func_lit        // (lit)
15DF: 02 00    | 0x0002           //     0x0002
15E1: 9C 07    | _func_minus      // -
15E3: 50 05    | _func_lit        // (lit)
15E5: BF 05    | _func_loop       //     (loop)
15E7: 9F 11    | _func_comma      // ,
15E9: 9F 11    | _func_comma      // ,
15EB: 50 05    | _func_lit        // (lit)
15ED: 14 06    | _func_UNLOOP     //     UNLOOP
15EF: 9F 11    | _func_comma      // ,
15F1: 5C 05    | _func_EXIT       // EXIT

15F3: 00
_ascii_LITERAL: | "LITERAL"
15F4: 4C 49 54 45 52 41 4C 00 01 94 15
_func_LITERAL:
15FF: 22 F1 18 | ent _func_apostrophe // '
1602: 50 05    | _func_lit            // (lit)
1604: 50 05    | _func_lit            //     (lit)
1606: 9F 11    | _func_comma          // ,
1608: 9F 11    | _func_comma          // ,
160A: 5C 05    | _func_EXIT           // EXIT

160C: 00
_ascii_POSTPONE: | "POSTPONE"
160D: 50 4F 53 54 50 4F 4E 45 00 01 FF 15
_func_POSTPONE:
1619: 22 F1 18 | ent _func_apostrophe // '          // a
161C: 49 06    | _func_DUP            // DUP        // a a
161E: 50 05    | _func_lit            // (lit)
1620: 03 00    | 0x0003               //     0x0003
1622: 9C 07    | _func_minus          // -          // a a-3
1624: 7F 07    | _func_Cat            // C@         // a C[a-3]
1626: 50 05    | _func_lit            // (lit)
1628: 01 00    | 0x0001               //     0x0001
162A: 86 08    | _func_AND            // AND        // a C[a-3]&1
162C: 7D 05    | _func_qbranch        // (?branch)
162E: 36 16    | 0x1636               //     0x1636
1630: 9F 11    | _func_comma          // ,          // Append direct call if immediate
1632: 6B 05    | _func_branch         // (branch)
1634: 3E 16    | 0x163E               //     0x163E
1636: 50 05    | _func_lit            // (lit)      // a (lit)
1638: 50 05    | _func_lit            //     (lit)
163A: 9F 11    | _func_comma          // ,          // a
163C: 9F 11    | _func_comma          // ,          // Append (lit) w/ address if not immediate
163E: 5C 05    | _func_EXIT           // EXIT

1640: 00
_ascii_RECURSE: | "RECURSE"
1641: 52 45 43 55 52 53 45 00 01 19 16
_func_RECURSE:
164C: 22 C2 10 | ent _func_VOCAB
164F: 73 07    | _func_at
1651: 9F 11    | _func_comma
1653: 5C 05    | _func_EXIT

1655: 00
_ascii_TICKS:  | "TICKS"
1656: 54 49 43 4B 53 00 00 4C 16
_func_TICKS:
165F: 22 56 06 | ent _func_qDUP
1662: 7D 05    | _func_qbranch
1664: 6E 16    | 0x166E
1666: A5 0D    | TICK
1668: DC 08    | _func_oneminus
166A: 6B 05    | _func_branch
166C: 60 16    | 0x1660
166E: 5C 05    | _func_EXIT

1670: 00
_ascii_SP0:    | "SP0"
1671: 53 50 30 00 00 5F 16
_func_SP0:
1678: 22 24 05 | ent _func_DOCON
167B: 00 02    |             // SP0 value (0x0200)

167D: 00
_ascii_RP0:    | "RP0"
167E: 52 50 30 00 00 78 16
_func_RP0:
1685: 22 24 05 | ent _func_DOCON
1688: 00 03    |             // RP0 value (0x0300)

168A: 00
_ascii_gtNAME: | ">NAME"
168B: 3E 4E 41 4D 45 00 00 85 16
_func_gtNAME:
1694: 22 50 05 | ent _func_lit // (lit)
1697: 05 00    | 0x0005        //     0x0005
1699: 9C 07    | _func_minus   // -
169B: 49 06    | _func_DUP     // DUP
169D: CD 0A    | _func_RSTRLEN // RSTRLEN
169F: 9C 07    | _func_minus   // -
16A1: D1 08    | _func_oneplus // 1+
16A3: 5C 05    | _func_EXIT    // EXIT

16A5: 00
_ascii_NAMEgt: | "NAME>"
16A6: 4E 41 4D 45 3E 00 00 94 16
_func_NAMEgt:
16AF: 22 49 06 | ent _func_DUP // DUP
16B2: A9 0A    | _func_STRLEN  // STRLEN
16B4: 8F 07    | _func_plus    // +
16B6: 50 05    | _func_lit     // (lit)
16B8: 06 00    | 0x0006        //     0x0006
16BA: 8F 07    | _func_plus    // +
16BC: 5C 05    | _func_EXIT    // EXIT

16BE: 00
_ascii_FIND:   | "FIND"
16BF: 46 49 4E 44 00 00 AF 16
_func_FIND:
16C7: 22 C2 10 | ent _func_VOCAB // VOCAB
16CA: 73 07    | _func_at        // @
16CC: 49 06    | _func_DUP       // DUP
16CE: 7D 05    | _func_qbranch   // (?branch)
16D0: 04 17    | 0x1704          //     0x1704
16D2: 65 06    | _func_2DUP      // 2DUP
16D4: 94 16    | _func_gtNAME    // >NAME
16D6: 8F 0C    | _func_STRCMP    // STRCMP
16D8: 13 09    | _func_zeroeq    // 0=
16DA: B3 06    | _func_OVER      // OVER
16DC: 50 05    | _func_lit       // (lit)
16DE: 03 00    | 0x0003          //    0x0003
16E0: 9C 07    | _func_minus     // -
16E2: 7F 07    | _func_Cat       // C@
16E4: 50 05    | _func_lit       // (lit)
16E6: 02 00    | 0x0002          //     0x0002
16E8: 86 08    | _func_AND       // AND
16EA: 13 09    | _func_zeroeq    // 0=
16EC: 86 08    | _func_AND       // AND
16EE: 7D 05    | _func_qbranch   // (?branch)
16F0: F8 16    | 0x16F8          //     0x16F8
16F2: EF 0A    | _func_TRUE      // TRUE
16F4: 6B 05    | _func_branch    // (branch)
16F6: 00 17    | 0x1700          //     0x1700
16F8: FD 09    | _func_CELL      // CELL
16FA: 9C 07    | _func_minus     // -
16FC: 73 07    | _func_at        // @
16FE: FE 0A    | _func_FALSE     // FALSE
1700: 6B 05    | _func_branch    // (branch)
1702: 06 17    | 0x1706          //     0x1706
1704: EF 0A    | _func_TRUE      // TRUE
1706: 7D 05    | _func_qbranch   // (?branch)
1708: CC 16    | 0x16CC          //     0x16CC
170A: 0B 07    | _func_NIP       // NIP
170C: 5C 05    | _func_EXIT      // EXIT

170E: 00
_ascii_ACCEPT: | "ACCEPT"
170F: 41 43 43 45 50 54 00 00 C7 16
_func_ACCEPT:
1719: 22 B3 06 | ent _func_OVER     // OVER
171C: 8F 07    | _func_plus         // +
171E: DC 08    | _func_oneminus     // 1-
1720: B3 06    | _func_OVER         // OVER
1722: 9E 0F    | _func_KEY          // KEY
1724: 49 06    | _func_DUP          // DUP
1736: 50 05    | _func_lit          // (lit)
1738: 0D 00    | 0x000D             // 0x000D
173A: 48 09    | _func_ltgt         // <>
173C: 7D 05    | _func_qbranch      // (?branch)
173E: 62 17    | 0x1762             //     0x1762
1730: 49 06    | _func_DUP          // DUP
1732: 50 05    | _func_lit          // (lit)
1734: 08 00    | 0x0008             //     0x0008
1736: E5 09    | _func_equals       // =
1738: 7D 05    | _func_qbranch      // (?branch)
173A: 50 17    | 0x1750             //     0x1750
173C: 75 06    | _func_DROP         // DROP
173E: C1 06    | _func_2OVER        // 2OVER
1740: B3 06    | _func_OVER         // OVER
1742: 5D 09    | _func_lt           // <
1744: 7D 05    | _func_qbranch      // (?branch)
1746: 4C 17    | 0x174C             //     0x174C
1748: 55 0F    | _func_BS           // BS
174A: DC 08    | _func_oneminus     // 1-
174C: 6B 05    | _func_branch       // (branch)
174E: 5E 17    | 0x175E             // 0x175E
1750: 49 06    | _func_DUP          // DUP
1752: 07 0F    | _func_EMIT         // EMIT
1754: B3 06    | _func_OVER         // OVER
1756: 64 07    | _func_Cexclamation // C!
1758: D1 08    | _func_oneplus      // 1+
175A: B3 06    | _func_OVER         // OVER
175C: 28 0A    | _func_MIN          // MIN
175E: 6B 05    | _func_branch       // (branch)
1760: 22 17    | 0x1722             //     0x1722
1762: 75 06    | _func_DROP         // DROP
1764: 28 0A    | _func_MIN          // MIN
1766: 50 05    | _func_lit          // (lit)
1768: 00 00    | 0x0000             //     0x0000
176A: 8D 06    | _func_SWAP         // SWAP
176C: 64 07    | _func_Cexclamation // C!
176E: 5C 05    | _func_EXIT         // EXIT

1770: 00
_ascii_zeroSP: | "0SP"
1771: 30 53 50 00 00 19 17
_func_zeroSP:
1778: 22 78 16 | ent _func_SP0       // SP0
177B: F3 08    | _func_SPexclamation // SP!
177D: 5C 05    | _func_EXIT          // EXIT

177F: 00
_ascii_INTERPRET: | "INTERPRET"
1780: 49 4E 54 45 52 50 52 45 54 00 00 78 17
_func_INTERPRET:
178D: 22 98 0B | ent _func_WORD     // WORD
1790: 49 06    | _func_DUP          // DUP
1792: A9 0A    | _func_STRLEN       // STRLEN
1794: 26 09    | _func_zeroltgt     // 0<>
1796: 7D 05    | _func_qbranch      // (?branch)
1798: 1A 18    | 0x181A             //     0x181A
179A: 8D 06    | _func_SWAP         // SWAP
179C: B3 10    | _func_TIBPTR       // TIBPTR
179E: 38 07    | _func_exclamation  // !
17A0: 49 06    | _func_DUP          // DUP
17A2: C7 16    | _func_FIND         // FIND
17A4: 56 06    | _func_qDUP         // ?DUP
17A6: 7D 05    | _func_qbranch      // (?branch)
17A8: DA 17    | 0x17DA             //     0x17DA
17AA: 0B 07    | _func_NIP          // NIP
17AC: FE 10    | _func_STATE        // STATE
17AE: 73 07    | _func_at           // @
17B0: 7D 05    | _func_qbranch      // (?branch)
18B2: D4 17    | 0x17D4             //     0x17D4
18B4: 49 06    | _func_DUP          // DUP
18B6: 50 05    | _func_lit          // (lit)
18B8: 03 00    | 0x0003             //     0x0003
18BA: 9C 07    | _func_minus        // -
18BC: 7F 07    | _func_Cat          // C@
18BE: 50 05    | _func_lit          // (lit)
17C0: 01 00    | 0x0001             //     0x0001
17C2: 86 08    | _func_AND          // AND
17C4: 7D 05    | _func_qbranch      // (?branch)
17C6: CE 17    | 0x17CE             //     0x17CE
17C8: 3D 06    | _func_EXECUTE      // EXECUTE
17CA: 6B 05    | _func_branch       // (branch)
17CC: D0 17    | 0x17D0             //     0x17D0
17CE: 9F 11    | _func_comma        // ,
17D0: 6B 05    | _func_branch       // (branch)
17D2: D6 17    | 0x17D6             //     0x17D6
17D4: 3D 06    | _func_EXECUTE      // EXECUTE
17D6: 6B 05    | _func_branch       // (branch)
17D8: 12 18    | 0x1812             //     0x1812
17DA: 49 06    | _func_DUP          // DUP
17DC: 7F 07    | _func_Cat          // C@
17DE: E2 0C    | _func_ISNUM        // ISNUM
17E0: 7D 05    | _func_qbranch      // (?branch)
17E2: FA 17    | 0x17FA             //     0x17FA
17E4: 55 0D    | _func_ATOI         // ATOI
17E6: FE 10    | _func_STATE        // STATE
17E8: 73 07    | _func_at           // @
17EA: 7D 05    | _func_qbranch      // (?branch)
17EC: F6 17    | 0x17F6             //     0x17F6
17EE: 50 05    | _func_lit          // (lit)
17F0: 50 05    | _func_lit          //     _func_lit
17F2: 9F 11    | _func_comma        // ,
17F4: 9F 11    | _func_comma        // ,
17F6: 6B 05    | _func_branch       // (branch)
17F8: 12 18    | 0x1812             //     0x1812
17FA: E2 0F    | _func_lpdotquoterp // (.")
_str_UnknownToken: | "Unknown Token: \0"
17FC: 55 6E 6B 6E 6F 77 6E 20 54 6F 6B 65 6E 3A 20 00
180C: 17 10    | _func_TYPE         // TYPE
180E: C7 0E    | _func_CR           // CR
1810: A1 10    | _func_ABORT        // ABORT
1812: B3 10    | _func_TIBPTR       // TIBPTR
1814: 73 07    | _func_at           // @
1816: 6B 05    | _func_branch       // (branch)
1818: 8E 17    | 0x178E             //     0x178E
181A: 75 06    | _func_DROP         // DROP
181C: 75 06    | _func_DROP         // DROP
181E: 5C 05    | _func_EXIT         // EXIT

1820: 00
_ascii_QUIT:   | "QUIT"
1821: 51 55 49 54 00 00 8D 17
_func_QUIT:
1829: 22 85 16 | ent _func_RP0       // RP0
182C: 09 09    | _func_RPexclamation // RP!
182E: 50 05    | _func_lit           // (lit)
1830: 00 00    | 0x0000              //     0x0000
1832: FE 10    | _func_STATE         // STATE
1834: 38 07    | _func_exclamation   // !
1836: B6 18    | _func_DEPTH         // DEPTH
1838: 36 09    | _func_zerolt        // 0<
183A: 7D 05    | _func_qbranch       // (?branch)
183C: 50 18    | 0x1850              //     0x1850
183E: E2 0F    | _func_lpdotquoterp  // (.")
_str_EmptyStack: | "Empty Stack\0"
1840: 45 6D 70 74 79 20 53 74 61 63 6B 00
184C: 78 16    | _func_SP0           // SP0
184E: F3 08    | _func_SPexclamation // SP!
1850: C7 0E    | _func_CR            // CR
1852: FE 10    | _func_TOP           // TOP
1854: 73 07    | _func_at            // @
1856: 13 09    | _func_zeroeq        // 0=
1858: 7D 05    | _func_qbranch       // (?branch)
185A: 65 18    | 0x1865              //     0x1865
185C: E2 0F    | _func_lpdotquoterp  // (.")
_str_gtspace:  | "> \0"
185E: 3E 20 00
1861: 6B 05    | _func_branch        // (branch)
1863: 71 18    | 0x1871              //     0x1871
1865: E2 0F    | _func_lpdotquoterp  // (.")
_str_: "compile: \0"
1867: 63 6F 6D 70 69 6C 65 3A 20 00
1871: 1C 0B    | _func_TIB           // TIB
1873: 50 05    | _func_lit           // (lit)
1875: 78 00    | 0x0078              //     0x0078
1877: 19 17    | _func_ACCEPT        // ACCEPT
1879: 07 10    | _func_SPACE         // SPACE
187B: 8D 17    | _func_INTERPRET     // INTERPRET
187D: 6B 05    | _func_branch        // (branch)
187F: 36 18    | 0x1836              //     0x1836

1881: 00
_ascii_WORDS:  | "WORDS"
1882: 57 4F 52 44 53 00 00 29 18
_func_WORDS:
188B: 22 C2 10 | ent _func_VOCAB // VOCAB
188E: 73 07    | _func_at        // @
1890: 49 06    | _func_DUP       // DUP
1892: 7D 05    | _func_qbranch   // (?branch)
1894: A8 18    | 0x18A8          //     0x18A8
1896: 49 06    | _func_DUP       // DUP
1898: 94 16    | _func_gtNAME    // >NAME
189A: 17 10    | _func_TYPE      // TYPE
189C: 07 10    | _func_SPACE     // SPACE
189E: FD 09    | _func_CELL      // CELL
18A0: 9C 07    | _func_minus     // -
18A2: 73 07    | _func_at        // @
18A4: 6B 05    | _func_branch    // (branch)
18A6: 90 18    | 0x1890          //     0x1890
18A8: 75 06    | _func_DROP      // DROP
18AA: 5C 05    | _func_EXIT      // EXIT

18AC: 00
_ascii_DEPTH:  | "DEPTH"
18AD: 44 45 50 54 48 00 00 8B 18
_func_DEPTH:
18B6: 22 E8 08 | ent _func_SPat // SP@
18B9: 78 16    | _func_SP0      // SP0
18BB: 8D 06    | _func_SWAP     // SWAP
18BD: 9C 07    | _func_minus    // -
18BF: 51 08    | _func_2slash   // 2/
18C1: 5C 05    | _func_EXIT     // EXIT

18C3: 00
_ascii_dotS:   | ".S"
18C4: 2E 53 00 00 B6 18
_func_dotS:
18CA: 22 B6 18 | ent _func_DEPTH // DEPTH      // DEPTH
18CD: 49 06    | _func_DUP       // DUP        // DEPTH DEPTH
18CE: 50 05    | _func_lit       // (lit)      // DEPTH DEPTH 0
18D1: 00 00    | 0x0000          //     0x0000
18D3: A2 05    | _func_qdo       // (?do)      // DEPTH
18D5: E7 18    | 0x18E7          //     0x18E7
18D7: 49 06    | _func_DUP       // DUP        // DEPTH DEPTH
18D9: 1D 06    | _func_I         // I          // DEPTH DEPTH I
18DB: 9C 07    | _func_minus     // -          // DEPTH DEPTH-I
18DD: 9B 06    | _func_PICK      // PICK       // DEPTH S[DEPTH-I]
18DF: 34 10    | _func_dot       // .          // DEPTH
18E1: BF 05    | _func_loop      // (loop)
18E3: D7 18    | 0x18D7          //     0x18D7
18E5: 14 06    | _func_UNLOOP    // UNLOOP     // DEPTH
18E7: 75 06    | _func_DROP      // DROP       //
18E9: 5C 05    | _func_EXIT      // EXIT

18EB: 00
_ascii_apostrophe: | "\'"
18EC: 27 00 00 CA 18
_func_apostrophe:
18F1: 22 EC 11 | ent _func_TIBWORD  // TIBWORD    // s
18F4: 49 06    | _func_DUP          // DUP        // s s
18F6: C7 16    | _func_FIND         // FIND       // s a
18F8: 56 06    | _func_qDUP         // ?DUP       // s a a
18FA: 13 09    | _func_zeroeq       // 0=         // s a 0=a
18FC: 7D 05    | _func_qbranch      // (?branch)  // s a
18FE: 1C 19    | 0x191C             //     0x191C
1900: E2 0F    | _func_lpdotquoterp // (.")
_str_UnknownToken: "Unknown Token: \0"
1902: 55 6E 6B 6E 6F 77 6E 20 54 6F 6B 65 6E 3A 20 00
1912: 17 10    | _func_TYPE         // TYPE
1914: C7 0E    | _func_CR           // CR
1916: A1 10    | _func_ABORT        // ABORT
1918: 6B 05    | _func_branch       // (branch)
191A: 1E 19    | 0x191E             //     0x191E
191C: 0B 07    | _func_NIP          // NIP        // a
191E: 5C 05    | _func_EXIT         // EXIT

1920: 00
_ascii_FORGET: | "FORGET"
1921: 46 4F 52 47 45 54 00 00 F1 18
_func_FORGET:
192B: 22 F1 18 | ent _func_apostrophe // '
192E: 49 06    | _func_DUP            // DUP
1930: 94 16    | _func_gtNAME         // >NAME
1932: DC 08    | _func_oneminus       // 1-
1934: D2 10    | _func_lpHERErp       // (HERE)
1936: 38 07    | _func_exclamation    // !
1938: FD 09    | _func_CELL           // CELL
193A: 9C 07    | _func_minus          // -
193C: 73 07    | _func_at             // @
193E: C2 10    | _func_VOCAB          // VOCAB
1940: 38 07    | _func_exclamation    // !
1942: 5C 05    | _func_EXIT           // EXIT

1944: 00
_ascii_IOXADDR: | "IOXADDR"
1945: 49 4F 58 41 44 44 52 00 00 2B 19
_func_IOXADDR:
1950: 22 34 05 | ent _func_DOVAR
_var_IOXADDR:
1953: 03 00

1955: 00
_ascii_IOXat:  | "IOX@"
1956: 49 4F 58 40 00 00 50 19
_func_IOXat
195E: 22 50 19 | ent _func_IOXADDR    // IOXADDR
1961: 73 07    | _func_at             // @
1963: B0 0D    | _func_RBPexclamation // RBP!
1965: 50 05    | _func_lit            // (lit)
1967: 00 03    | 0x0300               //     0x0300
1969: 73 07    | _func_at             // @
196B: 5C 05    | _func_EXIT           // EXIT

196D: 00
_ascii_IOXexclamation: | "IOX!"
196E: 49 4F 58 21 00 00 5E 19
_func_IOXexclamation:
1976: 22 50 19 | _func_IOXADDR        // IOXADDR
1979: 73 07    | _func_at             // @
197B: B0 0D    | _func_RBPexclamation // RBP!
197D: 50 05    | _func_lit            // (lit)
197F: 02 03    | 0x0302               //     0x0302
1981: 38 07    | _func_exclamation    // !
1983: 5C 05    | _func_EXIT           // EXIT

1985: 00
_ascii_IOXSET: | "IOXSET"
1986: 49 4F 58 53 45 54 00 00 76 19
_func_IOXSET:
1990: 22 50 19 | _func_IOXADDR        // IOXADDR
1993: 73 07    | _func_at             // @
1995: B0 0D    | _func_RBPexclamation // RBP!
1997: 50 05    | _func_lit            // (lit)
1999: 02 03    | 0x0302               //     0x0302
199B: 73 07    | _func_at             // @
199D: 93 08    | _func_OR             // OR
199F: 50 05    | _func_lit            // (lit)
19A1: 02 03    | 0x0302               //     0x0302
19A3: 38 07    | _func_exclamation    // !
19A5: 5C 05    | _func_EXIT           // EXIT

19A7: 00
_ascii_IOXRST: | "IOXRST"
19A8: 49 4F 58 52 53 54 00 00 90 19
_func_IOXRST:
19B2: 22 50 19 | _func_IOXADDR        // IOXADDR
19B5: 73 07    | _func_at             // @
19B7: B0 0D    | _func_RBPexclamation // RBP!
19B9: B2 08    | _func_INVERT         // INVERT
19BB: 50 05    | _func_lit            // (lit)
19BD: 02 03    | 0x0302               //     0x0302
19BF: 73 07    | _func_at             // @
19C1: 86 08    | _func_AND            // AND
19C3: 50 05    | _func_lit            // (lit)
19C5: 02 03    | 0x0302               //     0x0302
19C7: 38 07    | _func_exclamation    // !
19C9: 5C 05    | _func_EXIT           // EXIT

19CB: 00
_ascii_DISKADDR: | "DISKADDR"
19CC: 44 49 53 4B 41 44 44 52 00 00 B2 19 
_func_DISKADDR:
19D8: 22 34 05 | ent _func_DOVAR  // RHI(0x1D5F), I = 0x19DB, PC = 0x534
_var_DISKADDR:
19DB: 02 00    |             // Disk address value

19DD: 00
_ascii_DISKNAME: | "DISKNAME\""
19DE: 44 49 53 4B 4E 41 4D 45 22 00 00 D8 19
_func_DISKNAME:
19EB: 22 50 05 | ent _func_lit        // (lit)
19EE: 22 00    | 0x0022               //     '\"'
19F0: 08 12    | _func_TIBSPLIT       // TIBSPLIT
19F2: D8 19    | _func_DISKADDR       // DISKADDR
09F4: 73 07    | _func_at             // @
09F6: B0 0D    | _func_RBPexclamation // RBP!
09F8: 50 05    | _func_lit            // (lit)
09FA: 00 03    | 0x0300               //     0x0300
09FC: B3 06    | _func_OVER           // OVER
09FE: A9 0A    | _func_STRLEN         // STRLEN
1A00: D1 08    | _func_oneplus        // 1+
1A02: 39 0A    | _func_MOVE           // MOVE
1A04: 50 05    | _func_lit            // (lit)
1A06: 02 00    | 0x0002               //     0x0002
1A08: 50 05    | _func_lit            // (lit)
1A0A: 82 03    | 0x0382               //     0x0382
1A0C: 64 07    | _func_Cexclamation   // C!
1A0E: 50 05    | _func_lit            // (lit)
1A10: 82 03    | 0x0382               //     0x0382
1A12: 7F 07    | _func_Cat            // C@
1A14: 50 05    | _func_lit            // (lit)
1A16: 02 00    | 0x0002               //     0x0002
1A18: E5 09    | _func_equals         // =
1A1A: 7D 05    | _func_qbranch        // (?branch)
1A1C: 24 1A    | 0x1A24               //     0x1A24
1A1E: A5 0D    | _func_TICK           // TICK
1A20: 6B 05    | _func_branch         // (branch)
1A22: 0E 1A    | 0x1A0E               //     0x1A0E
1A24: 5C 05    | _func_EXIT           // EXIT

1A76: 00
_ascii_DISKID: | "DISKID"
1A27: 44 49 53 4B 49 44 00 00 EB 19
_func_DISKID:
1A31: 22 D8 19 | ent _func_DISKADDR   // DISKADDR
1A34: 73 07    | _func_at             // @
1A36: B0 0D    | _func_RBPexclamation // RBP!
1A38: 50 05    | _func_lit            // (lit)
1A3A: 03 00    | 0x0003               //     0x0003
1A3C: 50 05    | _func_lit            // (lit)
1A3E: 82 03    | 0x0382               //     0x0382
1A40: 64 07    | _func_Cexclamation   // C!
1A42: 50 05    | _func_lit            // (lit)
1A44: 82 03    | 0x0382               //     0x0382
1A46: 7F 07    | _func_Cat            // C@
1A48: 50 05    | _func_lit            // (lit)
1A4A: 03 00    | 0x0003               //     0x0003
1A4C: E5 09    | _func_equal          // =
1A4E: 7D 05    | _func_qbranch        // (?branch)
1A50: 58 1A    | 0x1A58               //     0x1A58
1A52: A5 0D    | _func_TICK           // TICK
1A54: 6B 05    | _func_branch         // (branch)
1A56: 42 1A    | 0x1A42               //     0x1A42
1A58: 50 05    | _func_lit            // (lit)
1A5A: 00 03    | 0x0300               //     0x0300
1A5C: 0F 0B    | _func_SCRATCH        // SCRATCH
1A5E: 50 05    | _func_lit            // (lit)
1A60: 40 00    | 0x0040               //     0x0040
1A62: 39 0A    | _func_MOVE           // MOVE
1A64: 0F 0B    | _func_SCRATCH        // SCRATCH
1A66: 17 10    | _func_TYPE           // TYPE
1A68: 5C 05    | _func_EXIT           // EXIT

1A6A: 00
_ascii_DISKWS:
1A6B: 44 49 53 4B 57 53 00 00 31 1A
_func_DISKWS:                                       // d s
1A75: 22 D8 19 | ent _func_DISKADDR   // DISKADDR   // d s DISKADDR
1A78: 73 07    | ent _func_at         // @          // d s [DISKADDR]
1A7A: B0 0D    | _func_RBPexclamation // RBP!       // d s
1A7C: 50 05    | _func_lit            // (lit)      // d s x380
1A7E: 80 03    | 0x0380               //     0x0380
1A80: 38 07    | _func_exclamation    // !          // d
1A82: 50 05    | _func_lit            // (lit)      // d x300
1A84: 00 03    | 0x0300               //     0x0300
1A86: 50 05    | _func_lit            // (lit)      // d x300 x80
1A88: 80 00    | 0x0080               //     0x0080
1A8A: 39 0A    | _func_MOVE           // MOVE       //
1A8C: 50 05    | _func_lit            // (lit)      // 5
1A8E: 05 00    | 0x0005               //     0x0005
1A90: 50 05    | _func_lit            // (lit)      // 5 x382
1A92: 82 03    | 0x0382               //     0x0382
1A94: 64 07    | _func_Cexclamation   // C!         //
1A96: 50 05    | _func_lit            // (lit)      // x382
1A98: 82 03    | 0x0382               //     0x0382
1A9A: 7F 07    | _func_Cat            // C@         // [x382]
1A9C: 50 05    | _func_lit            // (lit)      // [x382] 5
1A9E: 05 00    | 0x0005               //     0x0005
1AA0: E5 09    | _func_equals         // =          // [x382]=5
1AA2: 7D 05    | _func_qbranch        // (?branch)
1AA4: AC 1A    | 0x1AAC               //     0x1AAC
1AA6: A5 0D    | _func_TICK           // TICK
1AA8: 6B 05    | _func_branch         // (branch)
1AAA: 96 1A    | 0x1A96               //     0x1A96
1AAC: 5C 05    | _func_EXIT           // EXIT

1AAE: 00
_ascii_DISKRS
AEEF: 44 49 53 4B 52 53 00 00 75 1A
_func_DISKRS:
1AB9: 22 D8 19 | ent _func_DISKADDR   // DISKADDR
1ABC: 73 07    | _func_at             // @
1ABE: B0 0D    | _func_RBPexclamation // RBP!
1AC0: 50 05    | _func_lit            // (lit)
1AC2: 80 03    | 0x0380               //     0x0380
1AC4: 38 07    | _func_exclamation    // !
1AC6: 50 05    | _func_lit            // (lit)
1AC8: 04 00    | 0x0004               //     0x0004
1ACA: 50 05    | _func_lit            // (lit)
1ACC: 82 03    | 0x0382               //     0x0382
1ACE: 64 07    | _func_Cexclamation   // C!
1AD0: 50 05    | _func_lit            // (lit)
1AD2: 82 03    | 0x0382               //     0x0382
1AD4: 7F 07    | _func_Cat            // C@
1AD6: 50 05    | _func_lit            // (lit)
1AD8: 04 00    | 0x0004               //     0x0004
1ADA: E5 09    | _func_equals         // =
1ADC: 7D 05    | _func_qbranch        // (?branch)
1ADE: E6 1A    | 0x1AE6               //     0x1AE6
1AE0: A5 0D    | _func_TICK           // TICK
1AE2: 6B 05    | _func_branch         // (branch)
1AE4: D0 1A    | 0x1AD0               //     0x1AD0
1AE6: 50 05    | _func_lit            // (lit)
1AE8: 00 03    | 0x0300               //     0x0300
1AEA: 8D 06    | _func_SWAP           // SWAP
1AEC: 50 05    | _func_lit            // (lit)
1AEE: 80 00    | 0x0080               //     0x0080
1AF0: 39 0A    | _func_MOVE           // MOVE
1AF2: 5C 05    | _func_EXIT           // EXIT

1AF4: 00
_ascii_SAVE:   | "SAVE\""
1AF5: 53 41 56 45 22 00 00 B9 1A
_func_SAVE:
1AFE: 22 EB 19 | ent _func_DISKNAME // DISKNAME"
1B01: 50 05    | _func_lit          // (lit)
1B03: 00 05    | 0x0500             //     0x0500
1B05: E0 10    | _func_HERE         // HERE
1B07: 50 05    | _func_lit          // (lit)
1B09: 81 04    | 0x0481             //     0x0481
1B0B: 9C 07    | _func_minus        // -
1B0D: 50 05    | _func_lit          // (lit)
1B0F: 07 00    | 0x0007             //     0x0007
1B11: 60 08    | _func_Ugtgt        // U>>
1B13: 50 05    | _func_lit          // (lit)
1B15: 00 00    | 0x0000             //     0x0000
1B17: 8D 05    | _func_do           // (do)
1B19: 2D 1B    | 0x1B2D             //     0x1B2D
1B1B: 49 06    | _func_DUP          // DUP
1B1D: 1D 06    | _func_I            // I
1B1F: 75 1A    | _func_DISKWS       // DISKWS
1B21: 50 05    | _func_lit          // (lit)
1B23: 80 00    | 0x0080             //     0x0080
1B25: 8F 07    | _func_plus         // +
1B27: BF 05    | _func_loop         // (loop)
1B29: 1B 1B    | 0x1B1B             //     0x1B1B
1B2B: 14 06    | _func_UNLOOP       // UNLOOP
1B2D: 5C 05    | _func_EXIT         // EXIT

1B2F: 00
_ascii_blkbuf: | "(blkbuf)"
1B30: 28 62 6C 6B 62 75 66 29 00 00 FE 1A
_func_blkbuf:
1B3C: 22 34 05 | ent _func_DOVAR
_var_blkbuf:
1B3F: 00 00

1B41: 00
_ascii_blkno:  | "blkno"
1B42: 28 62 6C 6B 6E 6F 29 00 00 3C 1B
_func_blkno:
1B4D: 22 34 05 | ent _func_DOVAR
_var_blkno:
1B50: 00 00

1B52: 00
_ascii_blkup:  | "blkup"
1B53: 28 62 6C 6B 75 70 29 00 00 4D 
_func_blkup:
1B5E: 22 34 05 | ent _func_DOVAR
_var_blkup:
1B61: 00 00

1B63: 00
_ascii_FLUSH:  | "FLUSH"
1B64: 46 4C 55 53 48 00 00 5E 1B
_func_FLUSH:
1B6D: 22 3C 1B | ent _func_blkbuf  // (blkbuf)
1B70: 73 07    | _func_at          // @
1B72: 4D 1B    | _func_blkno       // (blkno)
1B74: 73 07    | _func_at          // @
1B76: DC 08    | _func_oneminus    // 1-
1B78: 50 05    | _func_lit         // (lit)
1B7A: 03 00    | 0x0003            //     0x0003
1B7C: 70 08    | _func_ltlt        // <<
1B7E: 50 05    | _func_lit         // (lit)
1B80: 08 00    | 0x0008            //     0x0008
1B82: 50 05    | _func_lit         // (lit)
1B84: 00 00    | 0x0000            //     0x0000
1B86: 8D 05    | _func_do          // (do)
1B88: A0 1B    | 0x1BA0            //     0x1BA0
1B8A: 65 06    | _func_2DUP        // 2DUP
1B8C: 75 1A    | _func_DISKWS      // DISKWS
1B8E: 8D 06    | _func_SWAP        // SWAP
1B90: 50 05    | _func_lit         // (lit)
1B92: 80 00    | 0x0080            //     0x0080
1B94: 8F 07    | _func_plus        // +
1B96: 8D 06    | _func_SWAP        // SWAP
1B98: D1 08    | _func_oneplus     // 1+
1B9A: BF 05    | _func_loop        // (loop)
1B9C: 8A 1B    | 0x1B8A            //     0x1B8A
1B9E: 14 06    | _func_UNLOOP      // UNLOOP
1BA0: 81 06    | _func_2DROP       // 2DROP
1BA2: 50 05    | _func_lit         // (lit)
1BA4: 00 00    | 0x0000            //     0x0000
1BA6: 5E 1B    | _func_blkup       // (blkup)
1BA8: 38 07    | _func_exclamation // !
1BAA: 5C 05    | _func_EXIT        // EXIT

1BAC: 00
_ascii_REVERT:
1BAD: 52 45 56 45 52 54 00 00 6D 1B
_func_REVERT:
1BB7: 22 50 05 | ent _func_lit     // (lit)
1BBA: 00 00    | 0x0000            //     0x0000
1BBC: 5E 1B    | _func_blkup       // (blkup)
1BBE: 38 07    | _func_exclamation // !
1BC0: 3C 1B    | _func_blkbuf      // (blkbuf)
1BC2: 73 07    | _func_at          // @
1BC4: 4D 1B    | _func_blkno       // (blkno)
1BC6: 73 07    | _func_at          // @
1BC8: DC 08    | _func_oneminus    // 1-
1BCA: 50 05    | _func_lit         // (lit)
1BCC: 03 00    | 0x0003            //     0x0003
1BCE: 70 08    | _func_ltlt        // <<
1BD0: 50 05    | _func_lit         // (lit)
1BD2: 08 00    | 0x0008            //     0x0008
1BD4: 50 05    | _func_lit         // (lit)
1BD6: 00 00    | 0x0000            //     0x0000
1BD8: 8D 05    | _func_do          // (do)
1BDA: F2 1B    | 0x1BF2            //     0x1BF2
1BDC: 65 06    | _func_2DUP        // 2DUP
1BDE: B9 1A    | _func_DISKRS      // DISKRS
1BE0: 8D 06    | _func_SWAP        // SWAP
1BE2: 50 05    | _func_lit         // (lit)
1BE4: 80 00    | 0x0080            //     0x0080
1BE6: 8F 07    | _func_plus        // +
1BE8: 8D 06    | _func_SWAP        // SWAP
1BEA: D1 08    | _func_oneplus     // 1+
1BEC: BF 05    | _func_loop        // (loop)
1BEE: DC 1B    | 0x1BDC            //     0x1BDC
1BF0: 14 06    | _func_UNLOOP      // UNLOOP
1BF2: 81 06    | _func_2DROP       // 2DROP
1BF4: 5C 05    | _func_EXIT        // EXIT

1BF6: 00
_ascii_BLOCK:  | "BLOCK"
1BF7: 42 4C 4F 43 4B 00 00 B7 1B
1C00: 22 3C 1B | ent _func_blkbuf  // (blkbuf)   // Ensure (blkbuf) is allocated
1C03: 73 07    | _func_at          // @
1C05: 13 09    | _func_zeroeq      // 0=
1C07: 7D 05    | _func_qbranch     // (?branch)
1C09: 15 1C    | 0x1C15            //     0x1C15
1C0B: 50 05    | _func_lit         // (lit)
1C0D: 00 04    | 0x0400            //     0x0400 // 1KiB
1C0F: 6A 11    | _func_ALLOT       // ALLOT
1C11: 3C 1B    | _func_blkbuf      // (blkbuf)
1C13: 38 07    | _func_exclamation // !

1C15: 49 06    | _func_DUP         // DUP
1C17: 4D 1B    | _func_blkno       // (blkno)
1C19: 73 07    | _func_at          // @
1C1B: E5 09    | _func_equals      // =
1C1D: 7D 05    | _func_qbranch     // (?branch)
1C1F: 29 1C    | 0x1C29            //     0x1C29
1C21: 75 06    | _func_DROP        // DROP       // Do nothing if block numbers are the same
1C23: 3C 1B    | _func_blkbuf      // (blkbuf)
1C25: 73 07    | _func_at          // @
1C27: 5C 05    | _func_EXIT        // EXIT

1C29: 4D 1B    | _func_blkno       // (blkno)
1C2B: 73 07    | _func_at          // @
1C2D: 26 09    | _func_zeroltgt    // 0<>
1C2F: 7D 05    | _func_qbranch     // (?branch)
1C31: 35 1C    | 0x1C35            //     0x1C35
1C33: 6D 1B    | _func_FLUSH       // FLUSH
1C35: 4D 1B    | _func_blkno       // (blkno)
1C37: 38 07    | _func_exclamation // !
1C39: B7 1B    | _func_REVERT      // REVERT
1C3B: 3C 1B    | _func_blkbuf      // (blkbuf)
1C3D: 73 07    | _func_at          // @
1C3F: 5C 05    | _func_EXIT        // EXIT

1C41: 00
_ascii_UPDATE: | "UPDATE"
1C42: 55 50 44 41 54 45 00 00 00 1C
1C4C: 22 50 05 | ent _func_lit     // (lit)
1C4F: 01 00    | 0x0001            //     0x0001
1C51: 5E 1B    | _func_blkup       // (blkup)
1C53: 38 07    | _func_exclamation // !
1C55: 5C 05    | _func_EXIT        // EXIT

1C57: 00
_ascii_LIST:   | "LIST"
1C58: 4C 49 53 54 00 00 4C 1C
1C60: 22 00 1C | ent _func_BLOCK
1C63: C7 0E    | _func_CR
1C65: 50 05    | _func_lit
1C67: 0A 00    | 0x000A
1C69: 2B 0B    | _func_RADIX
1C6B: 38 07    | _func_exclamation
1C6D: 50 05    | _func_lit
1C6F: 10 00    | 0x0010
1C71: 50 05    | _func_lit
1C73: 00 00    | 0x0000
1C75: 8D 05    | _func_do
1C77: AD 1C    | 0x1CAD
1C79: 1D 06    | _func_I
1C7B: 50 05    | _func_lit
1C7D: 0A 00    | 0x000A
1C7F: 5D 09    | _func_lt
1C81: 7D 05    | _func_qbranch
1C83: 87 1C    | 0x1C87
1C85: 07 10    | _func_SPACE
1C87: 1D 06    | _func_I
1C89: 34 10    | _func_dot
1C8B: 50 05    | _func_lit
1C8D: 40 00    | 0x0040
1C8F: 50 05    | _func_lit
1C91: 00 00    | 0x0000
1C93: 8D 05    | _func_do
1C95: A5 1C    | 0x1CA5
1C97: 49 06    | _func_DUP
1C99: 7F 07    | _func_Cat
1C9B: 07 0F    | _func_EMIT
1C9D: D1 08    | _func_oneplus
1C9F: BF 05    | _func_loop
1CA1: 97 1C    | 0x1C97
1CA3: 14 06    | _func_UNLOOP
1CA5: C7 0E    | _func_CR
1CA7: BF 05    | _func_loop
1CA9: 79 1C    | 0x1C79
1CAB: 14 06    | _func_UNLOOP
1CAD: 75 06    | _func_DROP
1CAF: 5C 05    | _func_EXIT

1CB1: 00
_ascii_WIPE:   | "WIPE"
1CB2: 57 49 50 45 00 00 60 1C
1CBA: 22 4C 1C | ent _func_UPDATE // UPDATE
1CBD: 3C 1B    | _func_blkbuf     // (blkbuf)
1CBF: 73 07    | _func_at         // @
1CC1: 50 05    | _func_lit        // (lit)
1CC3: 00 04    | 0x0400           //     0x0400
1CC5: 50 05    | _func_lit        // (lit)
1CC7: 20 00    | 0x0020           //     0x0020
1CC9: 58 0A    | _func_FILL       // FILL
1CCB: 5C 05    | _func_EXIT       // EXIT

1CCD: 00
_ascii_PP:     | "PP"
1CCE: 50 50 00 00 BA 1C
1CD4: 22 4C 1C | ent _func_UPDATE // UPDATE
1CD7: 50 05    | _func_lit        // (lit)
1CD9: 06 00    | 0x0006           //     0x0006
1CDB: 70 08    | _func_ltlt       // <<
1CDD: 3C 1B    | _func_blkbuf     // (blkbuf)
1CDF: 73 07    | _func_at         // @
1CE1: 8F 07    | _func_plus       // +
1CE3: 49 06    | _func_DUP        // DUP
1CE5: 50 05    | _func_lit        // (lit)
1CE7: 40 00    | 0x0040           //     0x0040
1CE9: 50 05    | _func_lit        // (lit)
1CEB: 20 00    | 0x0020           //     0x0020
1CED: 58 0A    | _func_FILL       // FILL
1CEF: 50 05    | _func_lit        // (lit)
1CF1: 0D 00    | 0x000D           //     0x000D
1CF3: 08 12    | _func_TIBSPLIT   // TIBSPLIT
1CF5: 18 07    | _func_TUCK       // TUCK
1CF7: A9 0A    | _func_STRLEN     // STRLEN
1CF9: 50 05    | _func_lit        // (lit)
1CFB: 40 00    | 0x0040           //     0x0040
1CFD: 28 0A    | _func_MIN        // MIN
1CFF: 39 0A    | _func_MOVE       // MOVE
1D01: 5C 05    | _func_EXIT       // EXIT

1D03: 00
_ascii_LOAD:   | "LOAD"
1D04: 4C 4F 41 44 00 00 D4 1C
1D0C: 22 00 1C | ent _func_BLOCK    // BLOCK
1D0F: 50 05    | _func_lit          // (lit)
1D11: 00 00    | 0x0000             //     0x0000
1D13: 1C 0B    | _func_TIB          // TIB
1D15: 50 05    | _func_lit          // (lit)
1D17: 40 00    | 0x0040             //     0x0040
1D19: 8F 07    | _func_plus         // +
1D1B: 64 07    | _func_Cexclamation // C!
1D1D: 50 05    | _func_lit          // (lit)
1D1F: 10 00    | 0x0010             //     0x0010
1D21: 50 05    | _func_lit          // (lit)
1D23: 00 00    | 0x0000             //     0x0000
1D25: 8D 05    | _func_do           // (do)
1D27: 49 1D    | 0x1D49             //     0x1D49
1D29: 49 06    | _func_DUP          // DUP
1D2B: 1C 0B    | _func_TIB          // TIB
1D2D: 50 05    | _func_lit          // (lit)
1D2F: 40 00    | 0x0040             //     0x0040
1D31: 39 0A    | _func_MOVE         // MOVE
1D33: 1C 0B    | _func_TIB          // TIB
1D35: B3 10    | _func_TIBPTR       // TIBPTR
1D37: 38 07    | _func_exclamation  // !
1D39: 1C 0B    | _func_TIB          // TIB
1D3B: 8D 17    | _func_INTERPRET    // INTERPRET
1D3D: 50 05    | _func_lit          // (lit)
1D3F: 40 00    | 0x0040             //     0x0040
1D41: 8F 07    | _func_plus         // +
1D43: BF 05    | _func_loop         // (loop)
1D45: 29 1D    | 0x1D29             //     0x1D29
1D47: 14 06    | _func_UNLOOP       // UNLOOP
1D49: 75 06    | _func_DROP         // DROP
1D4B: 5C 05    | _func_EXIT         // EXIT

1D4D: 00
_ascii_COLD:   | "COLD"
1D4E: 43 4F 4C 44 00 00 0C 1D 
_func_COLD:
1D56: 22 50 05 | ent _func_lit      // (lit)      // Read memory at 0x0000
1D59: 00 00    | 0x0000             //     0x0000
1D5B: 7F 07    | _func_Cat          // C@
1D5D: D8 19    | _func_DISKADDR     // DISKADDR   // Set DISKADDR to value
1D5F: 38 07    | _func_exclamation  // !
1D61: 50 05    | _func_lit          // (lit)      // Read memory at 0x0001
1D63: 01 00    | 0x0001              //    0x0001
1D65: 7F 07    | _func_Cat          // C@
1D67: C1 0D    | _func_TERMADDR     // TERMADDR   // Set TERMADDR to value
1D69: 38 07    | _func_exclamation  // !
1D6B: C7 0E    | _func_CR           // CR         // Print header
1D6D: C7 0E    | _func_CR           // CR
1D6F: E2 0F    | _func_lpdotquoterp // (.")
_str_MineOS:   | "MineOS V1.1 Initialized\0"
1D71: 4D 69 6E 65 4F 53 20 56 31 2E 31 20 49 6E 69 74 69 61 6C 69 7A 65 64 00
1D89: C7 0E    | _func_CR           // CR
1D8B: 0D 11    | _func_PROBE        // PROBE      // Compute free memory
1D8D: EF 10    | _func_TOP          // TOP
1D8F: 38 07    | _func_exclamation  // !
1D91: 55 11    | _func_FREE         // FREE
1D93: 5E 10    | _func_Udot         // U.         // Print free memory
1D95: E2 0F    | _func_lpdotquoterp // (.")
_str_bytesFree: "bytes free.\0"
1D97: 62 79 74 65 73 20 66 72 65 65 2E 00
1DA3: C7 0E    | _func_CR           // CR
1DA5: 29 18    | _func_QUIT         // QUIT       // Quit to shell
_var_HERE:
1DA7: 00 00    | ?
1DA9: 00 00 00 00 00 00 00
1DB0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
1DC0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
1DD0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
1DE0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
1DF0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
