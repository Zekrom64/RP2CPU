;;;;;;;;;;;;;;;;;;;;;
; Predefined Header ;
;;;;;;;;;;;;;;;;;;;;;

*= 0

MBYTE .macro
	sep #$20
	.as
.endm

MWORD .macro
	rep #$20
	.al
.endm

XBYTE .macro
	sep #$10
	.xs
.endm

XWORD .macro
	rep #$10
	.xl
.endm

MXBYTE .macro
	sep #$30
	.as
	.xs
.endm

MXWORD .macro
	rep #$30
	.al
	.xl
.endm

MMU_MAP = $00
MMU_GET_MAP = $80
MMU_SET_RB_OUT_OFFSET = $01
MMU_GET_RB_OUT_OFFSET = $81
MMU_RB_ENABLE = $02
MMU_RB_DISABLE = $82
MMU_SET_RB_IN_OFFSET = $03
MMU_GET_RB_IN_OFFSET = $83
MMU_RB_IN_ENABLE = $04
MMU_RB_IN_DISABLE = $84
MMU_SET_BRK = $05
MMU_GET_BRK = $85
MMU_SET_POR = $06
MMU_GET_POR = $86

;;;;;;;;;;;;;;;;;;;
; Macro Constants ;
;;;;;;;;;;;;;;;;;;;
REDBUS_WINDOW = $300

TERM_ROW = $300
TERM_CURX = $301
TERM_CURY = $302
TERM_CURMODE = $303
CURMODE_HIDE = $00
CURMODE_SOLID = $01
CURMODE_BLINK = $02
TERM_KB_START = $304
TERM_KB_POS = $305
TERM_KB_KEY = $306
TERM_BLIT_MODE = $307
BLITMODE_FILL = $01
BLITMODE_INVERT = $02
BLITMODE_SHIFT = $03
TERM_BLIT_SXFILL = $308
TERM_BLIT_SY = $309
TERM_BLIT_XOFF = $30A
TERM_BLIT_YOFF = $30B
TERM_BLIT_WIDTH = $30C
TERM_BLIT_HEIGHT = $30D
TERM_WINDOW = $310

DRIVE_SECBUF = $300
DRIVE_SECNUM = $380
DRIVE_CMD = $382
DRIVECMD_READNAME = $01
DRIVECMD_WRITENAME = $02
DRIVECMD_READSERIAL = $03
DRIVECMD_READSEC = $04
DRIVECMD_WRITESEC = $05

;;;;;;;;;;;;;
; Zero Page ;
;;;;;;;;;;;;;
.logical $00

_driveaddr .byte ?
_termaddr  .byte ?

_temp0 .word ?
_temp1 .word ?

_ptr_top_of_mem .word ?
_var_current_line .word ?
_ptr_end_of_text .word ?
_ptr_end_of_cmd .word ?

_text_cmdbuf .fill 81

_flags_state .byte ?

STATE_FLAG_COMMAND = $01

.here

*= $0

.logical $500
;;;;;;;;;;;;;;;
; Entry point ;
;;;;;;;;;;;;;;;
_start
	; Enter native mode
	clc
	xce

	; Set POR and BRK
	MXWORD
	lda #_por_start
	mmu #MMU_SET_POR
	lda #_brk_start
	mmu #MMU_SET_BRK
	
	; Clear Zero Page
	ldx #$0002
-	stz $00,X
	inx
	inx
	cpx #$0100
	bne -

	; Erase existing string
	stz _ptr_start_of_mem
	
	jmp _por_start
	
; BRK is used for debugging
_brk_start
	MXWORD
	sta _temp0 ; Save A to temp0
	txa
	tsx
	stx _temp1 ; Save S to temp1
	ldx #$100  ; Load S with top of zero page
	txs
	tax
	
	lda _termaddr ; Map the terminal
	zea
	mmu #MMU_MAP
	
	stz TERM_ROW ; Print first row, "Debug:"
	stz TERM_CURY
	lda #"De"
	sta TERM_WINDOW
	lda #"bu"
	sta TERM_WINDOW+2
	lda #"g:"
	sta TERM_WINDOW+4
	lda #"  "
	sta TERM_WINDOW+6
	sta TERM_WINDOW+8
	sta TERM_WINDOW+10
	sta TERM_WINDOW+12
	inc TERM_ROW; Next row
	
	lda #"A:" ; Display A
	sta TERM_WINDOW
	lda _temp0
	xba
	jsr _to_hex_chars
	sta TERM_WINDOW+2
	lda _temp0
	jsr _to_hex_chars
	sta TERM_WINDOW+4
	lda #"  "
	sta TERM_WINDOW+6
	lda #"S:" ; Display S
	sta TERM_WINDOW+8
	lda _temp1
	xba
	jsr _to_hex_chars
	sta TERM_WINDOW+10
	lda _temp1
	jsr _to_hex_chars
	sta TERM_WINDOW+12
	inc TERM_ROW
	
	lda #"D:" ; Display D
	sta TERM_WINDOW
	tda
	xba
	jsr _to_hex_chars
	sta TERM_WINDOW+2
	tda
	jsr _to_hex_chars
	sta TERM_WINDOW+4
	lda #"  "
	sta TERM_WINDOW+6
	lda #"R:" ; Display R
	sta TERM_WINDOW+8
	phx
	trx
	txa
	plx
	pha
	xba
	jsr _to_hex_chars
	sta TERM_WINDOW+10
	pla
	jsr _to_hex_chars
	sta TERM_WINDOW+12
	inc TERM_ROW
	
	lda #"X:" ; Display X
	sta TERM_WINDOW
	txa
	xba
	jsr _to_hex_chars
	sta TERM_WINDOW+2
	txa
	jsr _to_hex_chars
	sta TERM_WINDOW+4
	lda #"  "
	sta TERM_WINDOW+6
	lda #"I:" ; Display I
	sta TERM_WINDOW+8
	phx
	tix
	txa
	plx
	pha
	xba
	jsr _to_hex_chars
	sta TERM_WINDOW+10
	pla
	jsr _to_hex_chars
	sta TERM_WINDOW+12
	inc TERM_ROW
	
	lda #"Y:" ; Display Y
	sta TERM_WINDOW
	tya
	xba
	jsr _to_hex_chars
	sta TERM_WINDOW+2
	tya
	jsr _to_hex_chars
	sta TERM_WINDOW+4
	lda #" P"
	sta TERM_WINDOW+6
	lda #"C:" ; Display old PC
	sta TERM_WINDOW+8
	lda _temp1
	inc A
	tax
	lda $00,X
	dec A
	pha
	xba
	jsr _to_hex_chars
	sta TERM_WINDOW+10
	pla
	jsr _to_hex_chars
	sta TERM_WINDOW+12
	inc TERM_ROW
	
	lda #"P:" ; Display the flags
	sta TERM_WINDOW
	dex
	MBYTE
	lda $00,X
	MWORD
	jsr _to_hex_chars
	sta TERM_WINDOW+2
	
	stp ; Halt the CPU
	
_por_start
	; Setup the MMU
	MBYTE
	lda _termaddr
	mmu #MMU_MAP
	MXWORD
	
	lda #REDBUS_WINDOW
	mmu #MMU_SET_RB_OUT_OFFSET
	mmu #MMU_RB_ENABLE
	mmu #MMU_RB_IN_DISABLE

	; Detect available memory
	ldx #$1FFE
-	lda #$BEEF
	sta $00,X
	cmp $00,X
	bne +
	txa
	cmp #$FFFE
	beq +
	clc
	adc #$2000
	tax
	bra -
+	inx
	stx _ptr_top_of_mem
	
	; Clear the terminal
	jsr _term_clear
	
	; Set terminal memory row to 0
	; Set cursor to (6,0)
	MBYTE
	lda #$00
	sta TERM_ROW
	sta TERM_CURY
	lda #$06
	sta TERM_CURX
	MWORD
	
	; Draw line numbers
-	jsr _draw_linenum
	inc TERM_ROW
	lda TERM_ROW
	and #$00FF
	cmp #49
	bne -
	
	; Draw bottom row
	ldx #0
	lda #"__"
-	sta TERM_WINDOW,X
	inx
	inx
	cpx #80
	bne -
	
	lda TERM_ROW
	and #$FF00
	sta TERM_ROW
	
	; Set variables
	stz _var_current_line
	lda #_ptr_start_of_mem
	sta _ptr_end_of_text
	lda #_text_cmdbuf
	sta _ptr_end_of_cmd
	
;;;;;;;;;;;;;
; Main Loop ;
;;;;;;;;;;;;;
_main_loop
	jsr _input_poll

	wai
	bra _main_loop
	
;;;;;;;;;;;;;;;;;;
; Input Handling ;
;;;;;;;;;;;;;;;;;;

.as ; Accumulator is 8-bit for character handling
; Polls the keyboard for input
_input_poll
	sep #$20
	lda TERM_KB_POS
	cmp TERM_KB_START
	beq +
	lda TERM_KB_KEY
	inc TERM_KB_START
	jsr _input_key
+	rep #$20
	rts
	
; Inputs a key character
_input_key
	pha
	lda _flags_state
	bit #STATE_FLAG_COMMAND
	bne ++

	; Text input mode
	pla
	cmp #"~" ; Tilde, command key
	bne +
	; Toggle to command mode
	jsr _input_togglemode
	rts
	
+	jsr _input_textkey
	rts

	; Command mode
+	pla
	cmp #"~" ; Tilde, command key
	bne +
	; If start of buffer
	ldx _ptr_end_of_cmd
	cpx #_text_cmdbuf
	bne +
	; Print a '~', switch mode
	jsr _input_textkey
	jsr _input_togglemode
	rts

+	cmp #$0D ; Carriage return
	bne +
	; Run the command, toggle mode
	ldx _ptr_end_of_cmd
	stz $00,X
	jsr _input_runcmd
	jsr _input_togglemode
	; Cleanup command buffer
	ldx #_text_cmdbuf
	stx _ptr_end_of_cmd
	stz $00,X
	rts	

+	cmp #$08 ; Backspace
	bne ++
	; If not at start of buffer
	ldx _ptr_end_of_cmd
	cpx #_text_cmdbuf
	beq +
	; Go back one, erase character
	dex
	stz $00,X
	stx _ptr_end_of_cmd
	; Update display
	txa
	sec
	sbc #_text_cmdbuf
	tax
	lda #$DF
	sta TERM_WINDOW,X
+	rts
	
+	; If not at end of buffer
	ldx _ptr_end_of_cmd
	cpx #(_text_cmdbuf+80)
	beq +
	; Store character to buffer
	sta $00,X
	inx
	stx _ptr_end_of_cmd
	; Draw character to display
	dex
	pha
	txa
	sec
	sbc #_text_cmdbuf
	tax
	pla
	clc
	adc #$80
	sta TERM_WINDOW,X
+	rts
	
; Toggles between display and command mode
_input_togglemode
	lda _flags_state
	eor STATE_FLAG_COMMAND
	sta _flags_state
	bne +
	; Change to text mode
	; Clear command display line
	lda #49
	sta TERM_ROW
	ldx #0
	lda #"_"
-	sta TERM_WINDOW,X
	inx
	cpx #80
	bne -
	; Set cursor to blink
	lda #CURMODE_BLINK
	sta TERM_CURMODE
	; Set memory row to cursor Y
	lda TERM_CURY
	sta TERM_ROW	
	rts
	
+	; Change to command mode
	; Hide cursor
	lda #CURMODE_HIDE
	sta TERM_CURMODE
	; Set memory row to command display line
	lda #49
	sta TERM_ROW
	; Clear command display line
	ldx #0
	lda #$DF
-	sta TERM_WINDOW,X
	inx
	cpx #80
	bne -
	rts

; Runs the command currently in the command buffer
_input_runcmd
	ldx #_text_cmdbuf    ; X = command buffer pointer
	ldy #_table_commands ; Y = command table pointer
	
	; Compare character strings
-	lda $00,X
	cmp $00,Y ; If characters differ
	bne +
	lda $00,X ; End of command buffer
	beq ++
	inx
	iny
	bra -
	
+	lda $00,Y ; If command table entry ended
	bne -
	lda $00,X ; And 
	
+	

	
	rts

; Inputs a key in text mode
;;; TODO - Complete text input ;;;
_input_textkey
	cmp #$0D ; Carriage return
	bne +
	
+	cmp #$08 ; Backspace
	bne +

+	cmp #$09 ; Tab
	bne +
	
+	; Append the character to the display
	rts

.al

;;;;;;;;;;;;;;;;;;;;;
; Utility Functions ;
;;;;;;;;;;;;;;;;;;;;;
	
; Converts the 4-bit hex digit in A to its character, stored in A
_to_hex_digit
	; Work on bytes only
	sep #$20
	.as
	cmp #$0A
	bcc +    ; Jump if less than 0xA
	sbc #$0A ; A-F
	clc
	adc #"A"
	rep #$20
	rts
+	adc #"0" ; 0-9
	rep #$20
	rts
	.al

; Converts a hex byte in A to the pair of hexadecimal characters, stored in A
_to_hex_chars
	and #$00FF ; Mask
	pha        ; Save
	asl        ; << 4
	asl
	asl
	asl
	and #$0F00 ; Mask
	ora $00,S  ; Or
	and #$0F0F ; Mask
	jsr _to_hex_digit ; Call for both digits
	xba
	jsr _to_hex_digit
	sta $00,S  ; Clean stack
	pla
	rts

;;;;;;;;;;;;;;;;;;;;;
; Drawing Functions ;
;;;;;;;;;;;;;;;;;;;;;

; Clears the terminal
_term_clear
	; Prepare terminal
	lda #$20
	sta TERM_BLIT_SXFILL
	lda #$0000
	sta TERM_BLIT_XOFF
	lda #$3250
	sta TERM_BLIT_WIDTH
	; Store command and wait until ready
	MBYTE
	lda #BLITMODE_FILL
	sta TERM_BLIT_MODE
-	wai
	lda TERM_BLIT_MODE
	bne -
	MWORD
	rts
	
; Draws the line header for the current line in the terminal
_draw_linenum
	lda #" |" ; Draw sidebar
	sta TERM_WINDOW+4
	
	; Prepare loop
	ldx #4	
	lda TERM_ROW
	and #$00FF
	clc
	adc _var_current_line
	inc A
	clc
	
	; Draw the actual number
-	zea
	div _const_10 ; / by 10
	pha ; Save quotient
	tda ; Get remainder
	adc #"0"+$80 ; Convert to character
	MBYTE
	sta TERM_WINDOW,X ; Store character
	MWORD
	pla ; Restore quotient
	dex ; Next character
	cpx #$FFFF
	bne - ; Loop until 5 digits are drawn
	
	; Remove leading zeros
	inx
	MBYTE
-	lda #"0"+$80
	cmp TERM_WINDOW,X
	bne +
	lda #$A0
	sta TERM_WINDOW,X
+	inx
	cpx #4
	bne -
	MWORD
	
	rts

;;;;;;;;;;;;
; Commands ;
;;;;;;;;;;;;
.as ; Commands usually operate in 8-bit accumulator mode
; I is the command text pointer

; Skips leading whitespace
; Returns first non-whitespace character in A, I points to address
_cmdutil_skipspace
-	nxa
	beq + ; Null character
	cmp #$20 ; Space
	beq -
	cmp #$09 ; Tab
	beq -
	
	tix ; Decrement I before returning
	dex
	txi
+	rts

; Parses a number, returned in 16-bit A, I points after number
_cmdutil_parsenum
	jsr _cmdutil_skipspace
	cmp #0 ; Return 0 if end of string
	bne +
	rts
	
+	ldy #0 ; Y stores accumulated number
-	; Check if character is number
	cmp #"0"
	bcc ++
	cmp #"9"
	beq ++
	bcs +
	bra ++
	; Convert to number
+	sec
	sbc #"0"
	; Accumulate
	MWORD
	and #$00FF
	pha
	tya
	clc
	mul _const_10
	clc
	adc $00,S
	sta $00,S
	pla
	tay
	MBYTE
	; Next character
	nxa
	beq + ; Null character
	bra -
	
+	MWORD
	tya
	MBYTE
	tix ; Decrement I before returning
	dex
	txi
	rts

; "disk" | disk <n> | Sets the work disk to Redbus disk ID <n> 
_cmd_disk
	jsr _cmdutil_parsenum
	sta _var_workdisk
	rts

; "saveprefs" | saveprefs | Saves the preferences to the program disk
_cmd_saveprefs
	; Map the program disk drive
	lda _driveaddr
	mmu #MMU_MAP
	MWORD
	; Compute the sector address of the memory variables
	lda #_ptr_memvars
	tax
	clc
	zea
	div _const_128
	sta DRIVE_SECNUM
	; Copy to sector buffer
	ldx #0
-	lda _ptr_memvars,X
	sta DRIVE_SECBUF,X
	inx
	inx
	cpx #128
	bne -
	; Save sector to disk
	MBYTE
	lda #DRIVECMD_WRITESEC
	sta DRIVE_CMD
-	wai
	lda DRIVE_CMD
	beq +
	cmp #$FF
	beq +
	bra -
	; Remap the terminal
+	lda _termaddr
	mmu #MMU_MAP
	
	rts

.al

; Command table
_table_commands
	.null "disk"
	.word _cmd_disk
	.null "saveprefs"
	.word _cmd_saveprefs
	.byte 0

;;;;;;;;;;;;;;;;;;;;
; Memory Constants ;
;;;;;;;;;;;;;;;;;;;;
_const_10 .word 10
_const_128 .word 128

;;;;;;;;;;;;;;;;;;;;
; Memory Variables ;
;;;;;;;;;;;;;;;;;;;;
.align 128, $00
_ptr_memvars
_var_workdisk .byte 2
_var_tabsize .byte 4
	
_ptr_start_of_mem	
	
.here

.align 128, $00
