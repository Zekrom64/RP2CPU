;;;;;;;;;;;;;;;;;;;;;
; Predefined Header ;
;;;;;;;;;;;;;;;;;;;;;

*= 0

MBYTE .macro
	sep #$20
	.as
.endm

MWORD .macro
	rep #$20
	.al
.endm

XBYTE .macro
	sep #$10
	.xs
.endm

XWORD .macro
	rep #$10
	.xl
.endm

MXBYTE .macro
	sep #$30
	.as
	.xs
.endm

MXWORD .macro
	rep #$30
	.al
	.xl
.endm

MMU_MAP = $00
MMU_GET_MAP = $80
MMU_SET_RB_OUT_OFFSET = $01
MMU_GET_RB_OUT_OFFSET = $81
MMU_RB_ENABLE = $02
MMU_RB_DISABLE = $82
MMU_SET_RB_IN_OFFSET = $03
MMU_GET_RB_IN_OFFSET = $83
MMU_RB_IN_ENABLE = $04
MMU_RB_IN_DISABLE = $84
MMU_SET_BRK = $05
MMU_GET_BRK = $85
MMU_SET_POR = $06
MMU_GET_POR = $86

;;;;;;;;;;;;;;;;;;;
; Macro Constants ;
;;;;;;;;;;;;;;;;;;;
REDBUS_WINDOW = $300

TERM_ROW = $300
TERM_CURX = $301
TERM_CURY = $302
TERM_CURMODE = $303
CURMODE_HIDE = $00
CURMODE_SOLID = $01
CURMODE_BLINK = $02
TERM_KB_START = $304
TERM_KB_POS = $305
TERM_KB_KEY = $306
TERM_BLIT_MODE = $307
BLITMODE_FILL = $01
BLITMODE_INVERT = $02
BLITMODE_SHIFT = $03
TERM_BLIT_SXFILL = $308
TERM_BLIT_SY = $309
TERM_BLIT_XOFF = $30A
TERM_BLIT_YOFF = $30B
TERM_BLIT_WIDTH = $30C
TERM_BLIT_HEIGHT = $30D
TERM_WINDOW = $310

DRIVE_SECBUF = $300
DRIVE_SECNUM = $380
DRIVE_CMD = $382
DRIVECMD_READNAME = $01
DRIVECMD_WRITENAME = $02
DRIVECMD_READSERIAL = $03
DRIVECMD_READSEC = $04
DRIVECMD_WRITESEC = $05

;;;;;;;;;;;;;
; Zero Page ;
;;;;;;;;;;;;;
.logical $00

_driveaddr .byte ?
_termaddr  .byte ?

_temp0 .word ?
_temp1 .word ?

_ptr_top_of_mem .word ?
_var_current_line .word ?
_ptr_end_of_text .word ?
_ptr_end_of_cmd .word ?
_ptr_cursoraddr .word ?
_ptr_text_line .word ?

_text_cmdbuf .fill 81

_flags_state .byte ?

STATE_FLAG_COMMAND = $01

.here

*= $0

.logical $500
;;;;;;;;;;;;;;;
; Entry point ;
;;;;;;;;;;;;;;;
_start
	; Enter native mode
	clc
	xce

	; Set POR and BRK
	MXWORD
	lda #_por_start
	mmu #MMU_SET_POR
	lda #_brk_start
	mmu #MMU_SET_BRK
	
	; Clear Zero Page
	ldx #$0002
-	stz $00,X
	inx
	inx
	cpx #$0100
	bne -

	; Erase existing string
	stz _ptr_start_of_mem
	
	jmp _por_start
	
; BRK is used for debugging
_brk_start
	MXWORD
	sta _temp0 ; Save A to temp0
	txa
	tsx
	stx _temp1 ; Save S to temp1
	ldx #$100  ; Load S with top of zero page
	txs
	tax
	
	lda _termaddr ; Map the terminal
	zea
	mmu #MMU_MAP
	
	stz TERM_ROW ; Print first row, "Debug:"
	stz TERM_CURY
	lda #"De"
	sta TERM_WINDOW
	lda #"bu"
	sta TERM_WINDOW+2
	lda #"g:"
	sta TERM_WINDOW+4
	lda #"  "
	inc TERM_ROW; Next row
	
	lda #"A:" ; Display A
	sta TERM_WINDOW
	lda _temp0
	xba
	jsr _to_hex_chars
	sta TERM_WINDOW+2
	lda _temp0
	jsr _to_hex_chars
	sta TERM_WINDOW+4
	lda #"  "
	sta TERM_WINDOW+6
	lda #"S:" ; Display S
	sta TERM_WINDOW+8
	lda _temp1
	xba
	jsr _to_hex_chars
	sta TERM_WINDOW+10
	lda _temp1
	jsr _to_hex_chars
	sta TERM_WINDOW+12
	inc TERM_ROW
	
	lda #"D:" ; Display D
	sta TERM_WINDOW
	tda
	xba
	jsr _to_hex_chars
	sta TERM_WINDOW+2
	tda
	jsr _to_hex_chars
	sta TERM_WINDOW+4
	lda #"  "
	sta TERM_WINDOW+6
	lda #"R:" ; Display R
	sta TERM_WINDOW+8
	phx
	trx
	txa
	plx
	pha
	xba
	jsr _to_hex_chars
	sta TERM_WINDOW+10
	pla
	jsr _to_hex_chars
	sta TERM_WINDOW+12
	inc TERM_ROW
	
	lda #"X:" ; Display X
	sta TERM_WINDOW
	txa
	xba
	jsr _to_hex_chars
	sta TERM_WINDOW+2
	txa
	jsr _to_hex_chars
	sta TERM_WINDOW+4
	lda #"  "
	sta TERM_WINDOW+6
	lda #"I:" ; Display I
	sta TERM_WINDOW+8
	phx
	tix
	txa
	plx
	pha
	xba
	jsr _to_hex_chars
	sta TERM_WINDOW+10
	pla
	jsr _to_hex_chars
	sta TERM_WINDOW+12
	inc TERM_ROW
	
	lda #"Y:" ; Display Y
	sta TERM_WINDOW
	tya
	xba
	jsr _to_hex_chars
	sta TERM_WINDOW+2
	tya
	jsr _to_hex_chars
	sta TERM_WINDOW+4
	lda #" P"
	sta TERM_WINDOW+6
	lda #"C:" ; Display old PC
	sta TERM_WINDOW+8
	lda _temp1
	inc A
	tax
	lda $00,X
	dec A
	pha
	xba
	jsr _to_hex_chars
	sta TERM_WINDOW+10
	pla
	jsr _to_hex_chars
	sta TERM_WINDOW+12
	inc TERM_ROW
	
	lda #"P:" ; Display the flags
	sta TERM_WINDOW
	dex
	MBYTE
	lda $00,X
	MWORD
	jsr _to_hex_chars
	sta TERM_WINDOW+2
	
	stp ; Halt the CPU
	
_por_start
	; Setup the MMU
	MBYTE
	lda _termaddr
	mmu #MMU_MAP
	MXWORD
	
	lda #REDBUS_WINDOW
	mmu #MMU_SET_RB_OUT_OFFSET
	mmu #MMU_RB_ENABLE
	mmu #MMU_RB_IN_DISABLE

	; Detect available memory
	ldx #$1FFE
-	lda #$BEEF
	sta $00,X
	cmp $00,X
	bne +
	txa
	cmp #$FFFE
	beq +
	clc
	adc #$2000
	tax
	bra -
+	inx
	stx _ptr_top_of_mem
	
	; Clear the terminal
	jsr _term_clear
	
	; Set terminal memory row to 0
	; Set cursor to (6,0)
	MBYTE
	lda #$00
	sta TERM_ROW
	sta TERM_CURY
	lda #$06
	sta TERM_CURX
	MWORD
	
	; Set variables
	stz _var_current_line
	lda #_ptr_start_of_mem
	sta _ptr_end_of_text
	sta _ptr_cursoraddr
	sta _ptr_text_line
	lda #_text_cmdbuf
	sta _ptr_end_of_cmd
	
	jsr _draw_screen
	
	; Draw bottom row
	ldx #0
	lda #"__"
-	sta TERM_WINDOW,X
	inx
	inx
	cpx #80
	bne -
	
	lda TERM_ROW
	and #$FF00
	sta TERM_ROW
	
;;;;;;;;;;;;;
; Main Loop ;
;;;;;;;;;;;;;
_main_loop
	jsr _input_poll

	wai
	bra _main_loop
	
;;;;;;;;;;;;;;;;;;
; Input Handling ;
;;;;;;;;;;;;;;;;;;

.as ; Accumulator is 8-bit for character handling
; Polls the keyboard for input
_input_poll
	sep #$20
-	lda TERM_KB_POS
	cmp TERM_KB_START
	beq +
	lda TERM_KB_KEY
	inc TERM_KB_START
	jsr _input_key
	bra -
+	rep #$20
	rts
	
; Inputs a key character
_input_key
	pha
	lda _flags_state
	bit #STATE_FLAG_COMMAND
	bne ++

	; Text input mode
	pla
	cmp #"~" ; Tilde, command key
	bne +
	; Toggle to command mode
	jsr _input_togglemode
	rts
	
+	jsr _input_textkey
	rts

	; Command mode
+	pla
	cmp #"~" ; Tilde, command key
	bne +
	; If start of buffer
	ldx _ptr_end_of_cmd
	cpx #_text_cmdbuf
	bne +
	; Print a '~', switch mode
	jsr _input_textkey
	jsr _input_togglemode
	rts

+	cmp #$0D ; Carriage return
	bne +
	; Run the command, toggle mode
	ldx _ptr_end_of_cmd
	stz $00,X
	jsr _input_runcmd
	jsr _input_togglemode
	; Cleanup command buffer
	ldx #_text_cmdbuf
	stx _ptr_end_of_cmd
	stz $00,X
	rts	

+	cmp #$08 ; Backspace
	bne ++
	; If not at start of buffer
	ldx _ptr_end_of_cmd
	cpx #_text_cmdbuf
	beq +
	; Go back one, erase character
	dex
	stz $00,X
	stx _ptr_end_of_cmd
	; Update display
	txa
	sec
	sbc #_text_cmdbuf
	tax
	lda #$DF
	sta TERM_WINDOW,X
+	rts
	
+	; If not at end of buffer
	ldx _ptr_end_of_cmd
	cpx #(_text_cmdbuf+80)
	beq +
	; Store character to buffer
	sta $00,X
	inx
	stx _ptr_end_of_cmd
	; Draw character to display
	dex
	pha
	txa
	sec
	sbc #_text_cmdbuf
	tax
	pla
	clc
	adc #$80
	sta TERM_WINDOW,X
+	rts
	
; Toggles between display and command mode
_input_togglemode
	lda _flags_state
	eor STATE_FLAG_COMMAND
	sta _flags_state
	bne +
	; Change to text mode
	; Clear command display line
	lda #49
	sta TERM_ROW
	ldx #0
	lda #"_"
-	sta TERM_WINDOW,X
	inx
	cpx #80
	bne -
	; Set cursor to blink
	lda #CURMODE_BLINK
	sta TERM_CURMODE
	; Set memory row to cursor Y
	lda TERM_CURY
	sta TERM_ROW	
	rts
	
+	; Change to command mode
	; Hide cursor
	lda #CURMODE_HIDE
	sta TERM_CURMODE
	; Set memory row to command display line
	lda #49
	sta TERM_ROW
	; Clear command display line
	ldx #0
	lda #$DF
-	sta TERM_WINDOW,X
	inx
	cpx #80
	bne -
	rts

; Runs the command currently in the command buffer
_input_runcmd
	ldx #_table_commands ; I = command table pointer
	txi
	ldx #_text_cmdbuf    ; X = command buffer pointer
	txy                  ; Y = initial command buffer pointer
	
	; Compare character strings
-	nxa
	cmp #0
	beq +++   ; If end of table string
	cmp $00,X
	bne +     ; If strings don't match
	inx
	bra -
	
+
-	nxa   ; Seek to end of table entry
	cmp #0
	bne -
-	nxa   ; Skip command jump address
	nxa
	tix   ; Check if next entry is empty string
	lda $00,X
	bne +
	rts     ; If end of table, no command is run, return
	
+	tyx     ; Reset command buffer pointer
	bra --- ; Next entry
	
+	; Check next character in command buffer before running command
	lda $00,X ; If also null, run command
	beq +
	lda #' ' ; If not space, don't run command
	cmp $00,X
	bne -
	
	; Run the command, set I to command buffer pointer
+	MWORD
	nxa
	dec A
	pha
	MBYTE
	txi
	rts
	
; Inputs a key in text mode
;;; TODO - Complete text input ;;;
_input_textkey
	cmp #$08 ; Backspace
	beq +
	jmp _input_textkey_nonbs

	; Erase last character
+	ldx _ptr_cursoraddr
	cpx #_ptr_end_of_text
	bne +
	
	rts
	
	
+	dex ; 
	lda $00,X
	stz $00,X
	stx _ptr_end_of_text
	
	; Update display
	cmp #$0D ; Removed CR
	bne +
	
+	cmp #$09 ; Removed TAB
	bne +
	
	lda TERM_CURX
	sec
	sbc _var_tabsize
	sta TERM_CURX
	
	rts

+	; Removed regular character
	lda TERM_CURX
	dec A
	tax
	lda #' '
	sta TERM_WINDOW,X
	txa
	sta TERM_CURX
	rts

_input_textkey_nonbs
	cmp #$0D ; Carriage return
	bne +
	; Append character to text
	jsr _input_appendtext
	
	; Draw character to display
	

+	cmp #$09 ; Tab
	bne ++
	lda TERM_CURX
	clc
	adc _var_tabsize
	cmp #80 ; Don't append if it pushes the cursor off-screen
	bcc +
	rts
	
+	lda #$09
	; Append character to text
	jsr _input_appendtext
	
	; Draw character to display
	lda TERM_CURX
	ldx #0
	tax
	ldy #0
	lda _var_tabsize
	tay
	lda #' '
-	sta TERM_WINDOW,X
	inx
	dey
	bne -
	txa
	sta TERM_CURX
	
	rts
	
+	; Regular character
	pha
	lda TERM_CURX
	cmp #79 ; Don't append if it pushes the cursor off-screen
	bne +
	pla
	rts
	
+	pla
	; Append character to text
	jsr _input_appendtext
	
	; Append character to display
	pha
	lda TERM_CURX
	ldx #0
	tax
	pla
	sta TERM_WINDOW,X
	inc TERM_CURX
	
	rts
	
; Appends the character in A to the current text
_input_appendtext
	ldx _ptr_end_of_text
	sta $00,X
	inx
	stx _ptr_end_of_text
	stz $00,X
	rts

; Moves the text line pointer to the previous line	
_inpututil_prevline
	ldx _ptr_text_line
	cpx #_ptr_start_of_mem
	bne +
	rts
+	dex
	dex
	lda #$0D
-	cmp $00,X
	beq +
	cpx #_ptr_start_of_mem
	beq ++
	dex
	bra -

+	inx
+	stx _ptr_text_line
	rts

.al

;;;;;;;;;;;;;;;;;;;;;
; Utility Functions ;
;;;;;;;;;;;;;;;;;;;;;
	
; Converts the 4-bit hex digit in A to its character, stored in A
_to_hex_digit
	; Work on bytes only
	sep #$20
	.as
	cmp #$0A
	bcc +    ; Jump if less than 0xA
	sbc #$0A ; A-F
	clc
	adc #"A"
	rep #$20
	rts
+	adc #"0" ; 0-9
	rep #$20
	rts
	.al

; Converts a hex byte in A to the pair of hexadecimal characters, stored in A
_to_hex_chars
	and #$00FF ; Mask
	pha        ; Save
	asl        ; << 4
	asl
	asl
	asl
	and #$0F00 ; Mask
	ora $00,S  ; Or
	and #$0F0F ; Mask
	jsr _to_hex_digit ; Call for both digits
	xba
	jsr _to_hex_digit
	sta $00,S  ; Clean stack
	pla
	rts

;;;;;;;;;;;;;;;;;;;;;
; Drawing Functions ;
;;;;;;;;;;;;;;;;;;;;;

; Clears the terminal
_term_clear
	; Prepare terminal
	lda #$20
	sta TERM_BLIT_SXFILL
	lda #$0000
	sta TERM_BLIT_XOFF
	lda #$3150
	sta TERM_BLIT_WIDTH
	; Store command and wait until ready
	lda #BLITMODE_FILL
	jsr _term_runblit
	rts
	
; Runs a blit command with the terminal
_term_runblit
	php
	MBYTE
	sta TERM_BLIT_MODE
-	wai
	lda TERM_BLIT_MODE
	bne -
.al
	plp
	rts
	
; Draws the line header for the current line in the terminal
_draw_linenum
	lda #" |" ; Draw sidebar
	sta TERM_WINDOW+4
	
	; Prepare loop
	ldx #4	
	lda TERM_ROW
	and #$00FF
	clc
	adc _var_current_line
	inc A
	clc
	
	; Draw the actual number
-	zea
	div _const_10 ; / by 10
	pha ; Save quotient
	tda ; Get remainder
	adc #"0"+$80 ; Convert to character
	MBYTE
	sta TERM_WINDOW,X ; Store character
	MWORD
	pla ; Restore quotient
	dex ; Next character
	cpx #$FFFF
	bne - ; Loop until 5 digits are drawn
	
	; Remove leading zeros
	inx
	MBYTE
-	lda #"0"+$80
	cmp TERM_WINDOW,X
	bne +
	lda #$A0
	sta TERM_WINDOW,X
+	inx
	cpx #4
	bne -
	MWORD
	
	rts
	
.as
; Goes to the next line in the drawing string, returns ending character (CR, NUL)
_drawutil_nextline
-	nxa
	cmp #0
	beq +
	cmp #$0D
	beq +
	bra -
	rts
.al

; Redraws the entire screen at the current line	
_draw_screen
	; Clear the display
	jsr _term_clear
	MBYTE
	; Find line position in string
	ldx #_ptr_start_of_mem
	txi
	ldx _var_current_line
	beq +
-	jsr _drawutil_nextline
	cmp #0   ; String ends unexpectedly??
	beq +++
	dex
	cmp #0
	bne -
	
+	; Begin drawing string
	stz TERM_ROW
	rep #$20
	jsr _draw_linenum
	sep #$20
	ldx #6

-	nxa ; Next string character
	cmp #0
	beq ++ ; Exit if null
	cmp #$0D
	beq +  ; Next line if carriage return
	
	sta TERM_WINDOW,X ; Store and increment
	inx
	cpx #80 ; Keep looping if still on screen
	bne -
	jsr _drawutil_nextline
	cmp #0  ; Else, skip to next line, exit if end of string
	beq ++
	; Go to next line
	
+	; Increment row
	lda TERM_ROW
	inc A
	cmp #49 ; Exit if all lines are drawn
	beq +
	sta TERM_ROW ; Draw line number
	rep #$20
	jsr _draw_linenum
	sep #$20
	ldx #6 ; Restart string loop
	bra -

+	; Draw remaining lines
-	lda TERM_ROW
	cmp #49
	beq +
	rep #$20
	jsr _draw_linenum
	sep #$20
	inc TERM_ROW
	bra -
	
+	MWORD
	rts

;;;;;;;;;;;;
; Commands ;
;;;;;;;;;;;;
.as ; Commands usually operate in 8-bit accumulator mode
; I is the command text pointer

; Skips leading whitespace
; Returns first non-whitespace character in A, I points to address
_cmdutil_skipspace
-	nxa
	cmp #0
	beq + ; Null character
	cmp #$20 ; Space
	beq -
	cmp #$09 ; Tab
	beq -
	
	tix ; Decrement I before returning
	dex
	txi
+	rts

; Parses a number, returned in 16-bit A, I points after number
_cmdutil_parsenum
	jsr _cmdutil_skipspace
	cmp #0 ; Return 0 if end of string
	bne +
	MWORD
	lda #0
	MBYTE
	rts

+	ldy #0 ; Y stores accumulated number
-	nxa    ; Next character
	cmp #0 ; Break if null
	beq ++
	cmp #"0" ; Check if character is number
	bcc ++
	cmp #"9"
	beq +
	bcs ++
	; Convert to number
+	sec
	sbc #"0"
	; Accumulate
	MWORD
	and #$00FF
	pha
	tya
	clc
	mul _const_10
	clc
	adc $00,S
	sta $00,S
	pla
	tay
	MBYTE
	bra -
	
+	MWORD
	tya
	MBYTE
	tix ; Decrement I before returning
	dex
	txi
	rts

; "disk" | disk <n> | Sets the work disk to Redbus disk ID <n> 
_cmd_disk
	jsr _cmdutil_parsenum
	sta _var_workdisk
	rts

; "saveprefs" | saveprefs | Saves the preferences to the program disk
_cmd_saveprefs
	; Map the program disk drive
	lda _driveaddr
	mmu #MMU_MAP
	MWORD
	; Compute the sector address of the memory variables
	lda #_ptr_memvars
	sec
	sbc #$500
	clc
	zea
	div _const_128
	sta DRIVE_SECNUM
	; Copy to sector buffer
	ldx #0
-	lda _ptr_memvars,X
	sta DRIVE_SECBUF,X
	inx
	inx
	cpx #128
	bne -
	; Save sector to disk
	MBYTE
	lda #DRIVECMD_WRITESEC
	sta DRIVE_CMD
-	wai
	lda DRIVE_CMD
	beq +
	cmp #$FF
	beq +
	bra -
	; Remap the terminal
+	lda _termaddr
	mmu #MMU_MAP
	
	rts
	
_cmd_tabsize
	jsr _cmdutil_parsenum
	sta _var_tabsize
	rep #$20
	jsr _draw_screen
	sep #$20
	lda #6
	sta TERM_CURX
	rts
	
_cmd_name
	jsr _cmdutil_skipspace
	
	lda _var_workdisk
	mmu #MMU_MAP
	
	ldx #DRIVE_SECBUF
-	nxa
	cmp #0
	beq +
	sta $00,X
	inx
	bra -
	
+	cpx #DRIVE_SECBUF
	beq +
	
	stz $00,X
	
	lda #DRIVECMD_WRITENAME
	sta DRIVE_CMD
-	wai
	lda #$FF
	cmp DRIVE_CMD
	beq +
	lda DRIVE_CMD
	beq +
	bra -
	
+	lda _termaddr
	mmu #MMU_MAP
	rts
	
_cmd_write
	lda _var_workdisk
	mmu #MMU_MAP
	
	; Parse number and start at sector
	jsr _cmdutil_parsenum
	MWORD
	sta DRIVE_SECNUM
	MBYTE
	
	; I = data pointer
	ldx #_ptr_start_of_mem
	txi
	; X = byte counter
	ldx #0
	
	; Copy string bytes to sector buffer
-	nxa
	sta DRIVE_SECBUF,X
	cmp #0
	beq +
	inx
	cpx #$80
	bne -
	; Write current sector
	lda #DRIVECMD_WRITESEC
	jsr _disk_runcmd
	; Prepare next sector
	MWORD
	inc DRIVE_SECNUM
	MBYTE
	ldx #0
	bra -
	
	; Write final sector, pad with zeros
+	
-	cpx #$80
	beq +
	inx
	stz DRIVE_SECBUF,X
	bra -

+	lda #DRIVECMD_WRITESEC
	jsr _disk_runcmd

	lda _termaddr
	mmu #MMU_MAP
	rts

_cmd_read
	rts

.al

; Command table
_table_commands
	.null "disk"
	.word _cmd_disk
	.null "saveprefs"
	.word _cmd_saveprefs
	.null "tabsize"
	.word _cmd_tabsize
	.null "name"
	.word _cmd_name
	.null "write"
	.word _cmd_write
	.null "read"
	.word _cmd_read
	.byte 0
	
;;;;;;;;;;;;;;;;;;;
; Disk Operations ;
;;;;;;;;;;;;;;;;;;;

_disk_runcmd
	php
	MBYTE
	sta DRIVE_CMD
-	wai
	lda #$FF
	cmp DRIVE_CMD
	beq +
	lda DRIVE_CMD
	beq +
	bra -
+	plp
.al
	rts

;;;;;;;;;;;;;;;;;;;;
; Memory Constants ;
;;;;;;;;;;;;;;;;;;;;
_const_10 .word 10
_const_128 .word 128

;;;;;;;;;;;;;;;;;;;;
; Memory Variables ;
;;;;;;;;;;;;;;;;;;;;
.align 128, $00
_ptr_memvars
_var_workdisk .byte 3
_var_tabsize .byte 4
	
_ptr_start_of_mem	
	
.here

.align 128, $00
