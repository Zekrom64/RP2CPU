;;;;;;;;;;;;;;;;;;;;;
; Predefined Header ;
;;;;;;;;;;;;;;;;;;;;;

*= 0

MBYTE .macro
	sep #$20
	.as
.endm

MWORD .macro
	rep #$20
	.al
.endm

XBYTE .macro
	sep #$10
	.xs
.endm

XWORD .macro
	rep #$10
	.xl
.endm

MXBYTE .macro
	sep #$30
	.as
	.xs
.endm

MXWORD .macro
	rep #$30
	.al
	.xl
.endm

MMU_MAP = $00
MMU_GET_MAP = $80
MMU_SET_RB_OUT_OFFSET = $01
MMU_GET_RB_OUT_OFFSET = $81
MMU_RB_ENABLE = $02
MMU_RB_DISABLE = $82
MMU_SET_RB_IN_OFFSET = $03
MMU_GET_RB_IN_OFFSET = $83
MMU_RB_IN_ENABLE = $04
MMU_RB_IN_DISABLE = $84
MMU_SET_BRK = $05
MMU_GET_BRK = $85
MMU_SET_POR = $06
MMU_GET_POR = $86

;;;;;;;;;;;;;;;;;;;
; Macro Constants ;
;;;;;;;;;;;;;;;;;;;
REDBUS_WINDOW = $300

TERM_ROW = $300
TERM_CURX = $301
TERM_CURY = $302
TERM_CURMODE = $303
CURMODE_HIDE = $00
CURMODE_SOLID = $01
CURMODE_BLINK = $02
TERM_KB_START = $304
TERM_KB_POS = $305
TERM_KB_KEY = $306
TERM_BLIT_MODE = $307
BLITMODE_FILL = $01
BLITMODE_INVERT = $02
BLITMODE_SHIFT = $03
TERM_BLIT_SXFILL = $308
TERM_BLIT_SY = $309
TERM_BLIT_XOFF = $30A
TERM_BLIT_YOFF = $30B
TERM_BLIT_WIDTH = $30C
TERM_BLIT_HEIGHT = $30D
TERM_WINDOW = $310

DRIVE_SECBUF = $300
DRIVE_SECNUM = $380
DRIVE_CMD = $382
DRIVECMD_READNAME = $01
DRIVECMD_WRITENAME = $02
DRIVECMD_READSERIAL = $03
DRIVECMD_READSEC = $04
DRIVECMD_WRITESEC = $05

;;;;;;;;;;;;;
; Zero Page ;
;;;;;;;;;;;;;
.logical $00

driveaddr .byte ?
termaddr  .byte ?

temp0 .word ?
temp1 .word ?

ptr_top_of_mem .word ?
varw_current_line .word ?
ptr_end_of_text .word ?
ptr_end_of_cmd .word ?
ptr_cursoraddr .word ?
ptr_text_line .word ?
varw_num_lines .word ?

text_cmdbuf .fill 81

flags_state .byte ?

STATE_FLAG_COMMAND = $01

.here

*= $0

.logical $500
;;;;;;;;;;;;;;;
; Entry point ;
;;;;;;;;;;;;;;;
_start
	; Enter native mode
	clc
	xce

	; Set POR and BRK addresses
	MXWORD
	lda #_por_start
	mmu #MMU_SET_POR
	lda #_brk_start
	mmu #MMU_SET_BRK
	
	; Clear Zero Page (except Redbus IDs)
	ldx #$0002
-	stz $00,X
	inx
	inx
	cpx #$0100
	bne -

	; Hide any existing string
	stz cptr_start_of_mem
	
	jmp _por_start
	
; BRK is used for debugging
_brk_start
	MXWORD
	sta temp0 ; Save A to temp0
	txa
	tsx
	stx temp1 ; Save S to temp1
	ldx #$100  ; Load S with top of zero page
	txs
	tax
	
	lda termaddr ; Map the terminal
	and #$00FF
	mmu #MMU_MAP
	
	stz TERM_ROW ; Print first row, "Debug:"
	stz TERM_CURY
	lda #"De"
	sta TERM_WINDOW
	lda #"bu"
	sta TERM_WINDOW+2
	lda #"g:"
	sta TERM_WINDOW+4
	lda #"  "
	inc TERM_ROW; Next row
	
	lda #"A:" ; Display A
	sta TERM_WINDOW
	lda temp0
	xba
	jsr to_hex_chars
	sta TERM_WINDOW+2
	lda temp0
	jsr to_hex_chars
	sta TERM_WINDOW+4
	lda #"  "
	sta TERM_WINDOW+6
	lda #"S:" ; Display S
	sta TERM_WINDOW+8
	lda temp1
	xba
	jsr to_hex_chars
	sta TERM_WINDOW+10
	lda temp1
	jsr to_hex_chars
	sta TERM_WINDOW+12
	inc TERM_ROW
	
	lda #"D:" ; Display D
	sta TERM_WINDOW
	tda
	xba
	jsr to_hex_chars
	sta TERM_WINDOW+2
	tda
	jsr to_hex_chars
	sta TERM_WINDOW+4
	lda #"  "
	sta TERM_WINDOW+6
	lda #"R:" ; Display R
	sta TERM_WINDOW+8
	phx
	trx
	txa
	plx
	pha
	xba
	jsr to_hex_chars
	sta TERM_WINDOW+10
	pla
	jsr to_hex_chars
	sta TERM_WINDOW+12
	inc TERM_ROW
	
	lda #"X:" ; Display X
	sta TERM_WINDOW
	txa
	xba
	jsr to_hex_chars
	sta TERM_WINDOW+2
	txa
	jsr to_hex_chars
	sta TERM_WINDOW+4
	lda #"  "
	sta TERM_WINDOW+6
	lda #"I:" ; Display I
	sta TERM_WINDOW+8
	phx
	tix
	txa
	plx
	pha
	xba
	jsr to_hex_chars
	sta TERM_WINDOW+10
	pla
	jsr to_hex_chars
	sta TERM_WINDOW+12
	inc TERM_ROW
	
	lda #"Y:" ; Display Y
	sta TERM_WINDOW
	tya
	xba
	jsr to_hex_chars
	sta TERM_WINDOW+2
	tya
	jsr to_hex_chars
	sta TERM_WINDOW+4
	lda #" P"
	sta TERM_WINDOW+6
	lda #"C:" ; Display old PC
	sta TERM_WINDOW+8
	lda temp1
	inc A
	tax
	lda $00,X
	dec A
	pha
	xba
	jsr to_hex_chars
	sta TERM_WINDOW+10
	pla
	jsr to_hex_chars
	sta TERM_WINDOW+12
	inc TERM_ROW
	
	lda #"P:" ; Display the flags
	sta TERM_WINDOW
	dex
	MBYTE
	lda $00,X
	MWORD
	jsr to_hex_chars
	sta TERM_WINDOW+2
	
	stp ; Halt the CPU
	
_por_start
	; Setup the MMU
	MBYTE
	lda termaddr
	mmu #MMU_MAP
	MXWORD
	
	lda #REDBUS_WINDOW
	mmu #MMU_SET_RB_OUT_OFFSET
	mmu #MMU_RB_ENABLE
	mmu #MMU_RB_IN_DISABLE

	; Detect available memory
	ldx #$1FFE
-	lda #$BEEF
	sta $00,X
	cmp $00,X
	bne +
	txa
	cmp #$FFFE
	beq +
	clc
	adc #$2000
	tax
	bra -
+	inx
	stx ptr_top_of_mem
	
	; Set initial values of variables
	; Zero
	stz varw_current_line
	stz varw_num_lines
	
	; Start of memory pointer
	lda #cptr_start_of_mem
	sta ptr_end_of_text
	sta ptr_cursoraddr
	sta ptr_text_line
	
	; Start of text buffer pointer
	lda #text_cmdbuf
	sta ptr_end_of_cmd
	
	jsr draw_screen
	
	; Draw bottom row
	ldx #0
	lda #"__"
-	sta TERM_WINDOW,X
	inx
	inx
	cpx #80
	bne -
	
	; Set terminal memory row to 0
	; Set cursor to (6,0)
	MBYTE
	lda #$00
	sta TERM_ROW
	sta TERM_CURY
	lda #$06
	sta TERM_CURX
	MWORD
	
;;;;;;;;;;;;;
; Main Loop ;
;;;;;;;;;;;;;
_main_loop
	jsr input_poll

	wai
	bra _main_loop
	
;;;;;;;;;;;;;;;;;;
; Input Handling ;
;;;;;;;;;;;;;;;;;;

.as ; Accumulator is 8-bit for character handling
; Polls the keyboard for input
input_poll .proc
	sep #$20
-	lda TERM_KB_POS
	cmp TERM_KB_START
	beq +
	lda TERM_KB_KEY
	inc TERM_KB_START
	jsr input_key
	bra -
+	rep #$20
	rts
.pend
	
; Inputs a key character
input_key .proc
	pha
	lda flags_state
	bit #STATE_FLAG_COMMAND
	bne ++

	; Text input mode
	pla
	cmp #"~" ; Tilde, command key
	bne +
	; Toggle to command mode
	jsr input_togglemode
	rts
	
+	jsr input_textkey
	rts

	; Command mode
+	pla
	cmp #"~" ; Tilde, command key
	bne +
	; If start of buffer
	ldx ptr_end_of_cmd
	cpx #text_cmdbuf
	bne +
	; Print a '~', switch mode
	jsr input_togglemode
	jsr input_textkey
	rts
	
+	cmp #'4' ; Cursor back
	bne ++
	ldx ptr_cursoraddr
	cpx #cptr_start_of_mem
	bne +
	rts
	
+	lda $00,X
	cmp #$0D ; 
	rts
	
+	cmp #'6' ; Cursor forward
	bne ++
	ldx ptr_cursoraddr
	cpx ptr_end_of_text
	bne +
+	rts

+	cmp #$0D ; Carriage return
	bne +
	; Run the command, toggle mode
	ldx ptr_end_of_cmd
	stz $00,X
	jsr input_runcmd
	jsr input_togglemode
	; Cleanup command buffer
	ldx #text_cmdbuf
	stx ptr_end_of_cmd
	stz $00,X
	rts	

+	cmp #$08 ; Backspace
	bne ++
	; If not at start of buffer
	ldx ptr_end_of_cmd
	cpx #text_cmdbuf
	beq +
	; Go back one, erase character
	dex
	stz $00,X
	stx ptr_end_of_cmd
	; Update display
	txa
	sec
	sbc #text_cmdbuf
	tax
	lda #$DF
	sta TERM_WINDOW,X
+	rts
	
+	; If not at end of buffer
	ldx ptr_end_of_cmd
	cpx #(text_cmdbuf+80)
	beq +
	; Store character to buffer
	sta $00,X
	inx
	stx ptr_end_of_cmd
	; Draw character to display
	dex
	pha
	txa
	sec
	sbc #text_cmdbuf
	tax
	pla
	clc
	adc #$80
	sta TERM_WINDOW,X
+	rts
.pend
	
; Toggles between display and command mode
input_togglemode .proc
	lda flags_state
	eor STATE_FLAG_COMMAND
	sta flags_state
	bne +
	; Change to text mode
	; Clear command display line
	lda #49
	sta TERM_ROW
	ldx #0
	lda #"_"
-	sta TERM_WINDOW,X
	inx
	cpx #80
	bne -
	; Set cursor to blink
	lda #CURMODE_BLINK
	sta TERM_CURMODE
	; Set memory row to cursor Y
	lda TERM_CURY
	sta TERM_ROW	
	rts
	
+	; Change to command mode
	; Hide cursor
	lda #CURMODE_HIDE
	sta TERM_CURMODE
	; Set memory row to command display line
	lda #49
	sta TERM_ROW
	; Clear command display line
	ldx #0
	lda #$DF
-	sta TERM_WINDOW,X
	inx
	cpx #80
	bne -
	rts
.pend

; Runs the command currently in the command buffer
input_runcmd .proc
	ldx #table_commands ; I = command table pointer
	txi
	ldx #text_cmdbuf    ; X = command buffer pointer
	txy                  ; Y = initial command buffer pointer
	
	; Compare character strings
-	nxa
	cmp #0
	beq +++   ; If end of table string
	cmp $00,X
	bne +     ; If strings don't match
	inx
	bra -
	
+
-	nxa   ; Seek to end of table entry
	cmp #0
	bne -
-	nxa   ; Skip command jump address
	nxa
	tix   ; Check if next entry is empty string
	lda $00,X
	bne +
	rts     ; If end of table, no command is run, return
	
+	tyx     ; Reset command buffer pointer
	bra --- ; Next entry
	
+	; Check next character in command buffer before running command
	lda $00,X ; If also null, run command
	beq +
	lda #' ' ; If not space, don't run command
	cmp $00,X
	bne -
	
	; Run the command, set I to command buffer pointer
+	MWORD
	nxa
	dec A
	pha
	MBYTE
	txi
	rts
.pend
	
; Inputs a key in text mode
input_textkey .proc
	cmp #$08 ; Backspace
	beq +
	jmp _input_textkey_nonbs

	; Backspace handling is particularly complex
+	ldx ptr_cursoraddr 
	cpx #cptr_start_of_mem ; Can't backspace at start of text
	bne +
	rts
+	cpx ptr_end_of_text ; Special case if in middle of text
	beq _input_textkey_bsend
	
	dex
	lda $00,X ; Can't replace Tab or CR, skip
	cmp #$0D
	beq +
	cmp #$09
	bne ++
+	jsr inpututil_curback
	rts

+	lda #' ' ; Replace last character with a space
	sta $00,X
	stx ptr_cursoraddr
	dec TERM_CURX
	lda TERM_CURX
	ldx #0
	tax
	lda #' '
	sta TERM_WINDOW,X
	rts
	
; At end of text
_input_textkey_bsend
+	dex ; Easy in memory, just erase last character
	lda $00,X
	stz $00,X
	stx ptr_cursoraddr
	stx ptr_end_of_text
	
	; Updating the display, however, depends on character removed
	cmp #$0D ; Removed CR
	bne ++
	lda TERM_CURY
	; If we're at the top we need to scroll
	cmp #0
	beq +
	dec A
	sta TERM_CURY
	; TODO - Cursor to end of line
	rts
+	jsr draw_scrollup
	; TODO - Cursor to end of line
	rts
	
+	cmp #$09 ; Removed TAB
	bne +
	
	lda TERM_CURX ; Move cursor back by tab size, replace with spaces
	ldx #0
	tax
	lda varb_tabsize
	ldy #0
	tay
	lda #' '

-	sta TERM_WINDOW,X
	dex
	dey
	bpl -
	
	txa
	inc A
	sta TERM_CURX	
	rts

+	; Removed regular character
	; Replace with space, cursor back one
	lda TERM_CURX
	dec A
	tax
	lda #' '
	sta TERM_WINDOW,X
	txa
	sta TERM_CURX
	rts
	

; Non-backspace character input
_input_textkey_nonbs
	cmp #$0D ; Carriage return
	bne +
	; Append character to text
	jsr input_appendtext
	
	; Draw character to display
	rts

+	cmp #$09 ; Tab
	bne +++
	lda TERM_CURX
	clc
	adc varb_tabsize
	cmp #80 ; Don't append if it pushes the cursor off-screen
	bcc +
	rts
	
+	lda #$09
	; Append character to text
	jsr input_appendtext
	bcs +
	rts
	
	; Draw character to display
+	lda TERM_CURX
	ldx #0
	tax
	ldy #0
	lda varb_tabsize
	tay
	lda varb_tabchar
-	sta TERM_WINDOW,X
	inx
	dey
	bne -
	txa
	sta TERM_CURX
	
	rts
	
+	; Regular character
	pha
	lda TERM_CURX
	cmp #79 ; Don't append if it pushes the cursor off-screen
	bne +
	pla
	rts
	
+	pla
	; Append character to text
	jsr input_appendtext
	bcs +
	rts
	
	; Append character to display
+	pha
	lda TERM_CURX
	ldx #0
	tax
	pla
	sta TERM_WINDOW,X
	inc TERM_CURX
	
	rts
.pend
	
; Appends the character in A to the current text, carry indicates success
input_appendtext .proc
	ldx ptr_cursoraddr
	cpx ptr_end_of_text
	bne +
	
	; Easy if appending
	sta $00,X
	inx
	stz $00,X
	stx ptr_cursoraddr
	stx ptr_end_of_text
	sec
	rts
	
	; Special handling if not at end of text
+	cmp #$09 ; Tab or CR can only overwrite itself
	beq +
	cmp #$0D
	bne +++
+	pha
	lda $00,X
	
-	cmp $00,S
	clc
	bne +
	inx
	stx ptr_cursoraddr
	sec
+	pla
	rts

+	pha ; Can only overwrite a Tab or CR with itself
	lda $00,X
	cmp #$09 
	beq -
	cmp #$0D
	beq -

+	pla ; Overwrite character, increment
	sta $00,X
	inx
	stx ptr_cursoraddr
	sec
	rts
.pend

; Moves the text line pointer to the previous line	
inpututil_prevline .proc
	ldx ptr_text_line
	cpx #cptr_start_of_mem
	bne +
	rts
+	dex
	dex
	lda #$0D
-	cmp $00,X
	beq +
	cpx #cptr_start_of_mem
	beq ++
	dex
	bra -

+	inx
+	stx ptr_text_line
	rts
.pend

inpututil_curforward .proc

	rts
.pend

inpututil_curback .proc
	ldx ptr_cursoraddr
	cpx #cptr_start_of_mem
	bne +
	rts
+	dex
	stx ptr_cursoraddr
	lda $00,X
	
	cmp #$0D ; CR
	bne +
	
	
+	cmp #$09 ; Tab
	bne +
	lda TERM_CURX
	sec
	sbc varb_tabsize
	sta TERM_CURX
	rts
	
+	dec TERM_CURX
	rts
.pend

inpututil_curendofline .proc
	
.pend

.al

;;;;;;;;;;;;;;;;;;;;;
; Utility Functions ;
;;;;;;;;;;;;;;;;;;;;;
	
; Converts the 4-bit hex digit in A to its character, stored in A
to_hex_digit .proc
	; Work on bytes only
	sep #$20
	.as
	cmp #$0A
	bcc +    ; Jump if less than 0xA
	sbc #$0A ; A-F
	clc
	adc #"A"
	rep #$20
	rts
+	adc #"0" ; 0-9
	rep #$20
	rts
	.al
.pend

; Converts a hex byte in A to the pair of hexadecimal characters, stored in A
to_hex_chars .proc
	and #$00FF ; Mask
	pha        ; Save
	asl        ; << 4
	asl
	asl
	asl
	and #$0F00 ; Mask
	ora $00,S  ; Or
	and #$0F0F ; Mask
	jsr to_hex_digit ; Call for both digits
	xba
	jsr to_hex_digit
	sta $00,S  ; Clean stack
	pla
	rts
.pend

;;;;;;;;;;;;;;;;;;;;;
; Drawing Functions ;
;;;;;;;;;;;;;;;;;;;;;

; Clears the terminal
term_clear .proc
	php
	MWORD
	; Prepare terminal
	lda #$20
	sta TERM_BLIT_SXFILL
	lda #$0000
	sta TERM_BLIT_XOFF
	lda #$3150
	sta TERM_BLIT_WIDTH
	; Store command and wait until ready
	lda #BLITMODE_FILL
	jsr term_runblit
	plp
.al
	rts
.pend
	
; Runs a blit command with the terminal
term_runblit .proc
	php
	MBYTE
	sta TERM_BLIT_MODE
-	wai
	lda TERM_BLIT_MODE
	bne -
.al
	plp
	rts
.pend
	
; Draws the line header for the current line in the terminal
draw_linenum .proc
	php
	MWORD
	lda #" |" ; Draw sidebar
	sta TERM_WINDOW+4
	
	; Prepare loop
	ldx #4	
	lda TERM_ROW
	and #$00FF
	clc
	adc varw_current_line
	inc A
	clc
	
	; Draw the actual number
-	zea
	div const_10 ; / by 10
	pha ; Save quotient
	tda ; Get remainder
	adc #"0"+$80 ; Convert to character
	MBYTE
	sta TERM_WINDOW,X ; Store character
	MWORD
	pla ; Restore quotient
	dex ; Next character
	cpx #$FFFF
	bne - ; Loop until 5 digits are drawn
	
	; Remove leading zeros
	inx
	MBYTE
-	lda #"0"+$80
	cmp TERM_WINDOW,X
	bne +
	lda #$A0
	sta TERM_WINDOW,X
+	inx
	cpx #4
	bne -
	MWORD
	
	plp
	rts
.pend
	
.as
; Goes to the next line in the drawing string, returns ending character (CR, NUL)
drawutil_nextline .proc
-	nxa
	cmp #0
	beq +
	cmp #$0D
	beq +
	bra -
+	rts
.pend
.al

; Redraws the entire screen at the current line	
draw_screen .proc
	php
	; Clear the display
	jsr term_clear
	MBYTE
	; Find line position in string
	ldx #cptr_start_of_mem
	txi ; I = string pointer
	ldx varw_current_line
	beq +
-	jsr drawutil_nextline
	cmp #0   ; String ends unexpectedly??
	beq +++
	dex
	cmp #0
	bne -
	
+	; Begin drawing string
	stz TERM_ROW
	
	; Draw line
-	jsr draw_linenum
	jsr draw_line
	cmp #0 ; If line ends with null, finish drawing
	beq +
	inc TERM_ROW
	bra -

+	; Draw remaining lines
-	lda TERM_ROW
	cmp #49
	beq +
	jsr draw_linenum
	inc TERM_ROW
	bra -
	
+	plp
	rts
.pend
	
; Draws the next line in I to the current memory row, returns terminating character
draw_line .proc
	php
	MBYTE
	ldx #6
	
-	cpx #80 ; Escape if off-screen
	bcs ++
	
	nxa
	cmp #0 ; Escape if end of string
	beq ++
	
	cmp #$0D ; CR
	beq ++ ; Escape if end of line
	
	cmp #$09 ; TAB
	bne +
	ldy #0
	lda varb_tabsize ; Print varb_tabsize spaces of varb_tabchar
	tay
	lda varb_tabchar
-	sta TERM_WINDOW,X
	inx
	dey
	bne -
	bra --

+	sta TERM_WINDOW,X ; Append the character
	inx
	bra --
	
+	plp
.al
	rts
.pend
	

draw_scrollup .proc
	ldx varw_current_line
	cpx #0 ; Can't scroll up if at top
	bne +
	rts
	
+
.pend

draw_scrolldown .proc

.pend

;;;;;;;;;;;;
; Commands ;
;;;;;;;;;;;;
.as ; Commands usually operate in 8-bit accumulator mode
; I is the command text pointer

; Skips leading whitespace
; Returns first non-whitespace character in A, I points to address
cmdutil_skipspace .proc
-	nxa
	cmp #0
	beq + ; Null character
	cmp #$20 ; Space
	beq -
	cmp #$09 ; Tab
	beq -
	
	tix ; Decrement I before returning
	dex
	txi
+	rts
.pend

; Parses a number, returned in 16-bit A, I points after number
cmdutil_parsenum .proc
	jsr cmdutil_skipspace
	cmp #0 ; Return 0 if end of string
	bne +
	MWORD
	lda #0
	MBYTE
	rts

+	ldy #0 ; Y stores accumulated number
-	nxa    ; Next character
	cmp #0 ; Break if null
	beq ++
	cmp #"0" ; Check if character is number
	bcc ++
	cmp #"9"
	beq +
	bcs ++
	; Convert to number
+	sec
	sbc #"0"
	; Accumulate
	MWORD
	and #$00FF
	pha
	tya
	clc
	mul const_10
	clc
	adc $00,S
	sta $00,S
	pla
	tay
	MBYTE
	bra -
	
+	MWORD
	tya
	MBYTE
	tix ; Decrement I before returning
	dex
	txi
	rts
.pend

; "disk" | disk <n> | Sets the work disk to Redbus disk ID <n> 
cmd_disk .proc
	jsr cmdutil_parsenum
	sta varb_workdisk
	rts
.pend

; "saveprefs" | saveprefs | Saves the preferences to the program disk
cmd_saveprefs .proc
	; Map the program disk drive
	lda driveaddr
	mmu #MMU_MAP
	MWORD
	; Compute the sector address of the memory variables
	lda #cptr_memvars
	sec
	sbc #$500
	clc
	zea
	div const_128
	sta DRIVE_SECNUM
	; Copy to sector buffer
	ldx #0
-	lda cptr_memvars,X
	sta DRIVE_SECBUF,X
	inx
	inx
	cpx #128
	bne -
	; Save sector to disk
	MBYTE
	lda #DRIVECMD_WRITESEC
	sta DRIVE_CMD
-	wai
	lda DRIVE_CMD
	beq +
	cmp #$FF
	beq +
	bra -
	; Remap the terminal
+	lda termaddr
	mmu #MMU_MAP
	
	rts
.pend

; "tabsize" | tabsize <n> | Sets the size of Tab characters in spaces	
cmd_tabsize .proc
	jsr cmdutil_parsenum
	cmp #0
	beq +
	cmp #9 ; No ridiculous tab sizes
	bcs +
	sta varb_tabsize
	ldx ptr_text_line
	stx ptr_cursoraddr
	jsr draw_screen
	lda #6
	sta TERM_CURX
+	rts
.pend

; "diskname" | diskname <name> | Sets the name of the current work disk
cmd_diskname .proc
	jsr cmdutil_skipspace
	
	lda varb_workdisk
	mmu #MMU_MAP
	
	ldx #DRIVE_SECBUF
-	nxa
	cmp #0
	beq +
	sta $00,X
	inx
	bra -
	
+	cpx #DRIVE_SECBUF
	beq +
	
	stz $00,X
	
	lda #DRIVECMD_WRITENAME
	jsr disk_runcmd
	
+	lda termaddr
	mmu #MMU_MAP
	rts
.pend

; "write" | write [sec=0] | Writes the text to disk, starting at the given sector
cmd_write .proc
	lda varb_workdisk
	mmu #MMU_MAP
	
	; Parse number and start at sector
	jsr cmdutil_parsenum
	MWORD
	sta DRIVE_SECNUM
	MBYTE
	
	; I = data pointer
	ldx #cptr_start_of_mem
	txi
	; X = byte counter
	ldx #0
	
	; Copy string bytes to sector buffer
-	nxa
	sta DRIVE_SECBUF,X
	cmp #0
	beq +
	inx
	cpx #128
	bne -
	; Write current sector
	lda #DRIVECMD_WRITESEC
	jsr disk_runcmd
	; Prepare next sector
	MWORD
	inc DRIVE_SECNUM
	MBYTE
	ldx #0
	bra -
	
	; Write final sector, pad with zeros
+	
-	cpx #128
	beq +
	inx
	stz DRIVE_SECBUF,X
	bra -

+	lda #DRIVECMD_WRITESEC
	jsr disk_runcmd

	lda termaddr
	mmu #MMU_MAP
	rts
.pend

; "read" | read [sec=0] | Reads the text from disk, starting at the given sector
cmd_read .proc
	lda varb_workdisk
	mmu #MMU_MAP
	
	; Parse number and start at sector
	jsr cmdutil_parsenum
	MWORD
	sta DRIVE_SECNUM
	MBYTE
	
	ldx #cptr_start_of_mem ; X = memory pointer
	ldy #0 ; Y = sector byte counter
	
-	lda #DRIVECMD_READSEC
	jsr disk_runcmd
	
-	lda DRIVE_SECBUF,Y
	sta $00,X
	beq + ; Escape if null terminator is reached
	inx
	iny
	cpy #128
	bne -
	MWORD ; If done with current sector, read next
	inc DRIVE_SECNUM
	MBYTE
	bra --
	
+	lda termaddr
	mmu #MMU_MAP
	
	; Format the terminal and load variables
	
	MWORD
	; Current line is 0
	stz varw_current_line

	; Cursor & text line is at start of memory
	lda #cptr_start_of_mem
	sta ptr_cursoraddr
	sta ptr_text_line
	MBYTE

	; Reset cursor
	stz TERM_CURY
	lda #6
	sta TERM_CURX

	; Count lines & find end of text
	ldx #cptr_start_of_mem
	txi
	ldx #0
-	nxa
	cmp #0
	beq +
	cmp #$0D
	bne -
	inx
	bra -
	
+	stx varw_num_lines
	tix
	dex
	stx ptr_end_of_text
	
	; Redraw the screen
	jsr draw_screen
	
	rts
.pend

cmd_tabvis .proc
	lda #$09
	cmp varb_tabchar
	beq +
	sta varb_tabchar
	bra ++
+	lda #' '
	sta varb_tabchar
+	jsr draw_screen
	rts
.pend

.al

; Command table
table_commands
	.null "disk"
	.word cmd_disk
	.null "saveprefs"
	.word cmd_saveprefs
	.null "tabsize"
	.word cmd_tabsize
	.null "diskname"
	.word cmd_diskname
	.null "write"
	.word cmd_write
	.null "read"
	.word cmd_read
	.null "tabvis"
	.word cmd_tabvis
	.byte 0
	
;;;;;;;;;;;;;;;;;;;
; Disk Operations ;
;;;;;;;;;;;;;;;;;;;

disk_runcmd .proc
	php
	MBYTE
	sta DRIVE_CMD
-	wai
	lda #$FF
	cmp DRIVE_CMD
	beq +
	lda DRIVE_CMD
	beq +
	bra -
+	plp
.al
	rts
.pend

;;;;;;;;;;;;;;;;;;;;
; Memory Constants ;
;;;;;;;;;;;;;;;;;;;;
const_10 .word 10
const_128 .word 128

;;;;;;;;;;;;;;;;;;;;
; Memory Variables ;
;;;;;;;;;;;;;;;;;;;;
.align 128, $00
cptr_memvars
varb_workdisk .byte 3
varb_tabsize .byte 4
varb_tabchar .byte ' '
	
.align 128, $00
; Free memory
cptr_start_of_mem

.here

